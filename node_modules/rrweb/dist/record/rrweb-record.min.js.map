{"version":3,"file":"rrweb-record.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../../rrweb-snapshot/es/rrweb-snapshot.js","../../../src/types.ts","../../../src/utils.ts","../../../src/record/mutation.ts","../../../src/record/observer.ts","../../../src/record/iframe-manager.ts","../../../src/record/shadow-dom-manager.ts","../../../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../src/record/observers/canvas/serialize-args.ts","../../../src/record/observers/canvas/webgl.ts","../../../src/record/observers/canvas/canvas-manager.ts","../../../src/record/index.ts","../../../src/record/observers/canvas/canvas.ts","../../../src/record/observers/canvas/2d.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","var NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\n    return n.nodeType === n.ELEMENT_NODE;\n}\nfunction isShadowRoot(n) {\n    var _a;\n    var host = (_a = n) === null || _a === void 0 ? void 0 : _a.host;\n    return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\nfunction maskInputValue(_a) {\n    var maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;\n    var text = value || '';\n    if (maskInputOptions[tagName.toLowerCase()] ||\n        maskInputOptions[type]) {\n        if (maskInputFn) {\n            text = maskInputFn(text);\n        }\n        else {\n            text = '*'.repeat(text.length);\n        }\n    }\n    return text;\n}\nvar ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\nfunction is2DCanvasBlank(canvas) {\n    var ctx = canvas.getContext('2d');\n    if (!ctx)\n        return true;\n    var chunkSize = 50;\n    for (var x = 0; x < canvas.width; x += chunkSize) {\n        for (var y = 0; y < canvas.height; y += chunkSize) {\n            var getImageData = ctx.getImageData;\n            var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\n                : getImageData;\n            var pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n            if (pixelBuffer.some(function (pixel) { return pixel !== 0; }))\n                return false;\n        }\n    }\n    return true;\n}\n\nvar _id = 1;\nvar tagNameRegex = new RegExp('[^a-z0-9-_:]');\nvar IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName(element) {\n    if (element instanceof HTMLFormElement) {\n        return 'form';\n    }\n    var processedTagName = element.tagName.toLowerCase().trim();\n    if (tagNameRegex.test(processedTagName)) {\n        return 'div';\n    }\n    return processedTagName;\n}\nfunction getCssRulesString(s) {\n    try {\n        var rules = s.rules || s.cssRules;\n        return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n    }\n    catch (error) {\n        return null;\n    }\n}\nfunction getCssRuleString(rule) {\n    var cssStringified = rule.cssText;\n    if (isCSSImportRule(rule)) {\n        try {\n            cssStringified = getCssRulesString(rule.styleSheet) || cssStringified;\n        }\n        catch (_a) {\n        }\n    }\n    return cssStringified;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction stringifyStyleSheet(sheet) {\n    return sheet.cssRules\n        ? Array.from(sheet.cssRules)\n            .map(function (rule) { return rule.cssText || ''; })\n            .join('')\n        : '';\n}\nfunction extractOrigin(url) {\n    var origin = '';\n    if (url.indexOf('//') > -1) {\n        origin = url.split('/').slice(0, 3).join('/');\n    }\n    else {\n        origin = url.split('/')[0];\n    }\n    origin = origin.split('?')[0];\n    return origin;\n}\nvar canvasService;\nvar canvasCtx;\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nvar RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n    return (cssText || '').replace(URL_IN_CSS_REF, function (origin, quote1, path1, quote2, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        var maybeQuote = quote1 || quote2 || '';\n        if (!filePath) {\n            return origin;\n        }\n        if (!RELATIVE_PATH.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (filePath[0] === '/') {\n            return \"url(\" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + \")\";\n        }\n        var stack = href.split('/');\n        var parts = filePath.split('/');\n        stack.pop();\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            if (part === '.') {\n                continue;\n            }\n            else if (part === '..') {\n                stack.pop();\n            }\n            else {\n                stack.push(part);\n            }\n        }\n        return \"url(\" + maybeQuote + stack.join('/') + maybeQuote + \")\";\n    });\n}\nvar SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nvar SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var pos = 0;\n    function collectCharacters(regEx) {\n        var chars;\n        var match = regEx.exec(attributeValue.substring(pos));\n        if (match) {\n            chars = match[0];\n            pos += chars.length;\n            return chars;\n        }\n        return '';\n    }\n    var output = [];\n    while (true) {\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\n        if (pos >= attributeValue.length) {\n            break;\n        }\n        var url = collectCharacters(SRCSET_NOT_SPACES);\n        if (url.slice(-1) === ',') {\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n            output.push(url);\n        }\n        else {\n            var descriptorsStr = '';\n            url = absoluteToDoc(doc, url);\n            var inParens = false;\n            while (true) {\n                var c = attributeValue.charAt(pos);\n                if (c === '') {\n                    output.push((url + descriptorsStr).trim());\n                    break;\n                }\n                else if (!inParens) {\n                    if (c === ',') {\n                        pos += 1;\n                        output.push((url + descriptorsStr).trim());\n                        break;\n                    }\n                    else if (c === '(') {\n                        inParens = true;\n                    }\n                }\n                else {\n                    if (c === ')') {\n                        inParens = false;\n                    }\n                }\n                descriptorsStr += c;\n                pos += 1;\n            }\n        }\n    }\n    return output.join(', ');\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var a = doc.createElement('a');\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\n}\nfunction getHref() {\n    var a = document.createElement('a');\n    a.href = '';\n    return a.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (name === 'src' || (name === 'href' && value)) {\n        return absoluteToDoc(doc, value);\n    }\n    else if (name === 'xlink:href' && value && value[0] !== '#') {\n        return absoluteToDoc(doc, value);\n    }\n    else if (name === 'background' &&\n        value &&\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\n        return absoluteToDoc(doc, value);\n    }\n    else if (name === 'srcset' && value) {\n        return getAbsoluteSrcsetString(doc, value);\n    }\n    else if (name === 'style' && value) {\n        return absoluteToStylesheet(value, getHref());\n    }\n    else if (tagName === 'object' && name === 'data' && value) {\n        return absoluteToDoc(doc, value);\n    }\n    else {\n        return value;\n    }\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    if (typeof blockClass === 'string') {\n        if (element.classList.contains(blockClass)) {\n            return true;\n        }\n    }\n    else {\n        for (var eIndex = 0; eIndex < element.classList.length; eIndex++) {\n            var className = element.classList[eIndex];\n            if (blockClass.test(className)) {\n                return true;\n            }\n        }\n    }\n    if (blockSelector) {\n        return element.matches(blockSelector);\n    }\n    return false;\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector) {\n    if (!node) {\n        return false;\n    }\n    if (node.nodeType === node.ELEMENT_NODE) {\n        if (typeof maskTextClass === 'string') {\n            if (node.classList.contains(maskTextClass)) {\n                return true;\n            }\n        }\n        else {\n            for (var eIndex = 0; eIndex < node.classList.length; eIndex++) {\n                var className = node.classList[eIndex];\n                if (maskTextClass.test(className)) {\n                    return true;\n                }\n            }\n        }\n        if (maskTextSelector) {\n            if (node.matches(maskTextSelector)) {\n                return true;\n            }\n        }\n        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n    }\n    if (node.nodeType === node.TEXT_NODE) {\n        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    var win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    var fired = false;\n    var readyState;\n    try {\n        readyState = win.document.readyState;\n    }\n    catch (error) {\n        return;\n    }\n    if (readyState !== 'complete') {\n        var timer_1 = setTimeout(function () {\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener('load', function () {\n            clearTimeout(timer_1);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    var blankUrl = 'about:blank';\n    if (win.location.href !== blankUrl ||\n        iframeEl.src === blankUrl ||\n        iframeEl.src === '') {\n        setTimeout(listener, 0);\n        return;\n    }\n    iframeEl.addEventListener('load', listener);\n}\nfunction serializeNode(n, options) {\n    var _a;\n    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, inlineStylesheet = options.inlineStylesheet, _b = options.maskInputOptions, maskInputOptions = _b === void 0 ? {} : _b, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _c = options.dataURLOptions, dataURLOptions = _c === void 0 ? {} : _c, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;\n    var rootId;\n    if (doc.__sn) {\n        var docId = doc.__sn.id;\n        rootId = docId === 1 ? undefined : docId;\n    }\n    switch (n.nodeType) {\n        case n.DOCUMENT_NODE:\n            if (n.compatMode !== 'CSS1Compat') {\n                return {\n                    type: NodeType.Document,\n                    childNodes: [],\n                    compatMode: n.compatMode,\n                    rootId: rootId\n                };\n            }\n            else {\n                return {\n                    type: NodeType.Document,\n                    childNodes: [],\n                    rootId: rootId\n                };\n            }\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId,\n                rootId: rootId\n            };\n        case n.ELEMENT_NODE:\n            var needBlock = _isBlockedElement(n, blockClass, blockSelector);\n            var tagName = getValidTagName(n);\n            var attributes_1 = {};\n            for (var _i = 0, _d = Array.from(n.attributes); _i < _d.length; _i++) {\n                var _e = _d[_i], name_1 = _e.name, value = _e.value;\n                attributes_1[name_1] = transformAttribute(doc, tagName, name_1, value);\n            }\n            if (tagName === 'link' && inlineStylesheet) {\n                var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n                    return s.href === n.href;\n                });\n                var cssText = null;\n                if (stylesheet) {\n                    cssText = getCssRulesString(stylesheet);\n                }\n                if (cssText) {\n                    delete attributes_1.rel;\n                    delete attributes_1.href;\n                    attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n                }\n            }\n            if (tagName === 'style' &&\n                n.sheet &&\n                !(n.innerText ||\n                    n.textContent ||\n                    '').trim().length) {\n                var cssText = getCssRulesString(n.sheet);\n                if (cssText) {\n                    attributes_1._cssText = absoluteToStylesheet(cssText, getHref());\n                }\n            }\n            if (tagName === 'input' ||\n                tagName === 'textarea' ||\n                tagName === 'select') {\n                var value = n.value;\n                if (attributes_1.type !== 'radio' &&\n                    attributes_1.type !== 'checkbox' &&\n                    attributes_1.type !== 'submit' &&\n                    attributes_1.type !== 'button' &&\n                    value) {\n                    attributes_1.value = maskInputValue({\n                        type: attributes_1.type,\n                        tagName: tagName,\n                        value: value,\n                        maskInputOptions: maskInputOptions,\n                        maskInputFn: maskInputFn\n                    });\n                }\n                else if (n.checked) {\n                    attributes_1.checked = n.checked;\n                }\n            }\n            if (tagName === 'option') {\n                if (n.selected && !maskInputOptions['select']) {\n                    attributes_1.selected = true;\n                }\n                else {\n                    delete attributes_1.selected;\n                }\n            }\n            if (tagName === 'canvas' && recordCanvas) {\n                if (n.__context === '2d') {\n                    if (!is2DCanvasBlank(n)) {\n                        attributes_1.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n                    }\n                }\n                else if (!('__context' in n)) {\n                    var canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n                    var blankCanvas = document.createElement('canvas');\n                    blankCanvas.width = n.width;\n                    blankCanvas.height = n.height;\n                    var blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n                    if (canvasDataURL !== blankCanvasDataURL) {\n                        attributes_1.rr_dataURL = canvasDataURL;\n                    }\n                }\n            }\n            if (tagName === 'img' && inlineImages) {\n                if (!canvasService) {\n                    canvasService = doc.createElement('canvas');\n                    canvasCtx = canvasService.getContext('2d');\n                }\n                var image_1 = n;\n                var oldValue_1 = image_1.crossOrigin;\n                image_1.crossOrigin = 'anonymous';\n                var recordInlineImage = function () {\n                    try {\n                        canvasService.width = image_1.naturalWidth;\n                        canvasService.height = image_1.naturalHeight;\n                        canvasCtx.drawImage(image_1, 0, 0);\n                        attributes_1.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n                    }\n                    catch (err) {\n                        console.warn(\"Cannot inline img src=\" + image_1.currentSrc + \"! Error: \" + err);\n                    }\n                    oldValue_1\n                        ? (attributes_1.crossOrigin = oldValue_1)\n                        : delete attributes_1.crossOrigin;\n                };\n                if (image_1.complete && image_1.naturalWidth !== 0)\n                    recordInlineImage();\n                else\n                    image_1.onload = recordInlineImage;\n            }\n            if (tagName === 'audio' || tagName === 'video') {\n                attributes_1.rr_mediaState = n.paused\n                    ? 'paused'\n                    : 'played';\n                attributes_1.rr_mediaCurrentTime = n.currentTime;\n            }\n            if (n.scrollLeft) {\n                attributes_1.rr_scrollLeft = n.scrollLeft;\n            }\n            if (n.scrollTop) {\n                attributes_1.rr_scrollTop = n.scrollTop;\n            }\n            if (needBlock) {\n                var _f = n.getBoundingClientRect(), width = _f.width, height = _f.height;\n                attributes_1 = {\n                    \"class\": attributes_1[\"class\"],\n                    rr_width: width + \"px\",\n                    rr_height: height + \"px\"\n                };\n            }\n            if (tagName === 'iframe' && !keepIframeSrcFn(attributes_1.src)) {\n                if (!n.contentDocument) {\n                    attributes_1.rr_src = attributes_1.src;\n                }\n                delete attributes_1.src;\n            }\n            return {\n                type: NodeType.Element,\n                tagName: tagName,\n                attributes: attributes_1,\n                childNodes: [],\n                isSVG: isSVGElement(n) || undefined,\n                needBlock: needBlock,\n                rootId: rootId\n            };\n        case n.TEXT_NODE:\n            var parentTagName = n.parentNode && n.parentNode.tagName;\n            var textContent = n.textContent;\n            var isStyle = parentTagName === 'STYLE' ? true : undefined;\n            var isScript = parentTagName === 'SCRIPT' ? true : undefined;\n            if (isStyle && textContent) {\n                try {\n                    if (n.nextSibling || n.previousSibling) {\n                    }\n                    else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\n                        textContent = stringifyStyleSheet(n.parentNode.sheet);\n                    }\n                }\n                catch (err) {\n                    console.warn(\"Cannot get CSS styles from text's parentNode. Error: \" + err, n);\n                }\n                textContent = absoluteToStylesheet(textContent, getHref());\n            }\n            if (isScript) {\n                textContent = 'SCRIPT_PLACEHOLDER';\n            }\n            if (!isStyle &&\n                !isScript &&\n                needMaskingText(n, maskTextClass, maskTextSelector) &&\n                textContent) {\n                textContent = maskTextFn\n                    ? maskTextFn(textContent)\n                    : textContent.replace(/[\\S]/g, '*');\n            }\n            return {\n                type: NodeType.Text,\n                textContent: textContent || '',\n                isStyle: isStyle,\n                rootId: rootId\n            };\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: '',\n                rootId: rootId\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || '',\n                rootId: rootId\n            };\n        default:\n            return false;\n    }\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === undefined) {\n        return '';\n    }\n    else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n        return true;\n    }\n    else if (sn.type === NodeType.Element) {\n        if (slimDOMOptions.script &&\n            (sn.tagName === 'script' ||\n                (sn.tagName === 'link' &&\n                    sn.attributes.rel === 'preload' &&\n                    sn.attributes.as === 'script') ||\n                (sn.tagName === 'link' &&\n                    sn.attributes.rel === 'prefetch' &&\n                    typeof sn.attributes.href === 'string' &&\n                    sn.attributes.href.endsWith('.js')))) {\n            return true;\n        }\n        else if (slimDOMOptions.headFavicon &&\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n                (sn.tagName === 'meta' &&\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\n            return true;\n        }\n        else if (sn.tagName === 'meta') {\n            if (slimDOMOptions.headMetaDescKeywords &&\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaSocial &&\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaRobots &&\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaHttpEquiv &&\n                sn.attributes['http-equiv'] !== undefined) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaAuthorship &&\n                (lowerIfExists(sn.attributes.name) === 'author' ||\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            }\n            else if (slimDOMOptions.headMetaVerification &&\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n, options) {\n    var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, _h = options.keepIframeSrcFn, keepIframeSrcFn = _h === void 0 ? function () { return false; } : _h;\n    var _j = options.preserveWhiteSpace, preserveWhiteSpace = _j === void 0 ? true : _j;\n    var _serializedNode = serializeNode(n, {\n        doc: doc,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        maskTextClass: maskTextClass,\n        maskTextSelector: maskTextSelector,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        keepIframeSrcFn: keepIframeSrcFn\n    });\n    if (!_serializedNode) {\n        console.warn(n, 'not serialized');\n        return null;\n    }\n    var id;\n    if ('__sn' in n) {\n        id = n.__sn.id;\n    }\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n        (!preserveWhiteSpace &&\n            _serializedNode.type === NodeType.Text &&\n            !_serializedNode.isStyle &&\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\n        id = IGNORED_NODE;\n    }\n    else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, { id: id });\n    n.__sn = serializedNode;\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    map[id] = n;\n    if (onSerialize) {\n        onSerialize(n);\n    }\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n        if (n.shadowRoot)\n            serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType.Document ||\n        serializedNode.type === NodeType.Element) &&\n        recordChild) {\n        if (slimDOMOptions.headWhitespace &&\n            _serializedNode.type === NodeType.Element &&\n            _serializedNode.tagName === 'head') {\n            preserveWhiteSpace = false;\n        }\n        var bypassOptions = {\n            doc: doc,\n            map: map,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: skipChild,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOMOptions: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            inlineImages: inlineImages,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n            keepIframeSrcFn: keepIframeSrcFn\n        };\n        for (var _i = 0, _k = Array.from(n.childNodes); _i < _k.length; _i++) {\n            var childN = _k[_i];\n            var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n            if (serializedChildNode) {\n                serializedNode.childNodes.push(serializedChildNode);\n            }\n        }\n        if (isElement(n) && n.shadowRoot) {\n            for (var _l = 0, _m = Array.from(n.shadowRoot.childNodes); _l < _m.length; _l++) {\n                var childN = _m[_l];\n                var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedChildNode.isShadow = true;\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n    }\n    if (n.parentNode && isShadowRoot(n.parentNode)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType.Element &&\n        serializedNode.tagName === 'iframe') {\n        onceIframeLoaded(n, function () {\n            var iframeDoc = n.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                var serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    map: map,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n, options) {\n    var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.maskTextClass, maskTextClass = _d === void 0 ? 'rr-mask' : _d, _e = _a.maskTextSelector, maskTextSelector = _e === void 0 ? null : _e, _f = _a.inlineStylesheet, inlineStylesheet = _f === void 0 ? true : _f, _g = _a.inlineImages, inlineImages = _g === void 0 ? false : _g, _h = _a.recordCanvas, recordCanvas = _h === void 0 ? false : _h, _j = _a.maskAllInputs, maskAllInputs = _j === void 0 ? false : _j, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _k = _a.slimDOM, slimDOM = _k === void 0 ? false : _k, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _l = _a.keepIframeSrcFn, keepIframeSrcFn = _l === void 0 ? function () { return false; } : _l;\n    var idNodeMap = {};\n    var maskInputOptions = maskAllInputs === true\n        ? {\n            color: true,\n            date: true,\n            'datetime-local': true,\n            email: true,\n            month: true,\n            number: true,\n            range: true,\n            search: true,\n            tel: true,\n            text: true,\n            time: true,\n            url: true,\n            week: true,\n            textarea: true,\n            select: true,\n            password: true\n        }\n        : maskAllInputs === false\n            ? {\n                password: true\n            }\n            : maskAllInputs;\n    var slimDOMOptions = slimDOM === true || slimDOM === 'all'\n        ?\n            {\n                script: true,\n                comment: true,\n                headFavicon: true,\n                headWhitespace: true,\n                headMetaDescKeywords: slimDOM === 'all',\n                headMetaSocial: true,\n                headMetaRobots: true,\n                headMetaHttpEquiv: true,\n                headMetaAuthorship: true,\n                headMetaVerification: true\n            }\n        : slimDOM === false\n            ? {}\n            : slimDOM;\n    return [\n        serializeNodeWithId(n, {\n            doc: n,\n            map: idNodeMap,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: false,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOMOptions: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            inlineImages: inlineImages,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n            keepIframeSrcFn: keepIframeSrcFn\n        }),\n        idNodeMap,\n    ];\n}\nfunction visitSnapshot(node, onVisit) {\n    function walk(current) {\n        onVisit(current);\n        if (current.type === NodeType.Document ||\n            current.type === NodeType.Element) {\n            current.childNodes.forEach(walk);\n        }\n    }\n    walk(node);\n}\nfunction cleanupSnapshot() {\n    _id = 1;\n}\n\nvar commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options) {\n    if (options === void 0) { options = {}; }\n    var lineno = 1;\n    var column = 1;\n    function updatePosition(str) {\n        var lines = str.match(/\\n/g);\n        if (lines) {\n            lineno += lines.length;\n        }\n        var i = str.lastIndexOf('\\n');\n        column = i === -1 ? column + str.length : str.length - i;\n    }\n    function position() {\n        var start = { line: lineno, column: column };\n        return function (node) {\n            node.position = new Position(start);\n            whitespace();\n            return node;\n        };\n    }\n    var Position = (function () {\n        function Position(start) {\n            this.start = start;\n            this.end = { line: lineno, column: column };\n            this.source = options.source;\n        }\n        return Position;\n    }());\n    Position.prototype.content = css;\n    var errorsList = [];\n    function error(msg) {\n        var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);\n        err.reason = msg;\n        err.filename = options.source;\n        err.line = lineno;\n        err.column = column;\n        err.source = css;\n        if (options.silent) {\n            errorsList.push(err);\n        }\n        else {\n            throw err;\n        }\n    }\n    function stylesheet() {\n        var rulesList = rules();\n        return {\n            type: 'stylesheet',\n            stylesheet: {\n                source: options.source,\n                rules: rulesList,\n                parsingErrors: errorsList\n            }\n        };\n    }\n    function open() {\n        return match(/^{\\s*/);\n    }\n    function close() {\n        return match(/^}/);\n    }\n    function rules() {\n        var node;\n        var rules = [];\n        whitespace();\n        comments(rules);\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n            if (node !== false) {\n                rules.push(node);\n                comments(rules);\n            }\n        }\n        return rules;\n    }\n    function match(re) {\n        var m = re.exec(css);\n        if (!m) {\n            return;\n        }\n        var str = m[0];\n        updatePosition(str);\n        css = css.slice(str.length);\n        return m;\n    }\n    function whitespace() {\n        match(/^\\s*/);\n    }\n    function comments(rules) {\n        if (rules === void 0) { rules = []; }\n        var c;\n        while ((c = comment())) {\n            if (c !== false) {\n                rules.push(c);\n            }\n            c = comment();\n        }\n        return rules;\n    }\n    function comment() {\n        var pos = position();\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n            return;\n        }\n        var i = 2;\n        while ('' !== css.charAt(i) &&\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\n            ++i;\n        }\n        i += 2;\n        if ('' === css.charAt(i - 1)) {\n            return error('End of comment missing');\n        }\n        var str = css.slice(2, i - 2);\n        column += 2;\n        updatePosition(str);\n        css = css.slice(i);\n        column += 2;\n        return pos({\n            type: 'comment',\n            comment: str\n        });\n    }\n    function selector() {\n        var m = match(/^([^{]+)/);\n        if (!m) {\n            return;\n        }\n        return trim(m[0])\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, function (m) {\n            return m.replace(/,/g, '\\u200C');\n        })\n            .split(/\\s*(?![^(]*\\)),\\s*/)\n            .map(function (s) {\n            return s.replace(/\\u200C/g, ',');\n        });\n    }\n    function declaration() {\n        var pos = position();\n        var propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n        if (!propMatch) {\n            return;\n        }\n        var prop = trim(propMatch[0]);\n        if (!match(/^:\\s*/)) {\n            return error(\"property missing ':'\");\n        }\n        var val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n        var ret = pos({\n            type: 'declaration',\n            property: prop.replace(commentre, ''),\n            value: val ? trim(val[0]).replace(commentre, '') : ''\n        });\n        match(/^[;\\s]*/);\n        return ret;\n    }\n    function declarations() {\n        var decls = [];\n        if (!open()) {\n            return error(\"missing '{'\");\n        }\n        comments(decls);\n        var decl;\n        while ((decl = declaration())) {\n            if (decl !== false) {\n                decls.push(decl);\n                comments(decls);\n            }\n            decl = declaration();\n        }\n        if (!close()) {\n            return error(\"missing '}'\");\n        }\n        return decls;\n    }\n    function keyframe() {\n        var m;\n        var vals = [];\n        var pos = position();\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n            vals.push(m[1]);\n            match(/^,\\s*/);\n        }\n        if (!vals.length) {\n            return;\n        }\n        return pos({\n            type: 'keyframe',\n            values: vals,\n            declarations: declarations()\n        });\n    }\n    function atkeyframes() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?keyframes\\s*/);\n        if (!m) {\n            return;\n        }\n        var vendor = m[1];\n        m = match(/^([-\\w]+)\\s*/);\n        if (!m) {\n            return error('@keyframes missing name');\n        }\n        var name = m[1];\n        if (!open()) {\n            return error(\"@keyframes missing '{'\");\n        }\n        var frame;\n        var frames = comments();\n        while ((frame = keyframe())) {\n            frames.push(frame);\n            frames = frames.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@keyframes missing '}'\");\n        }\n        return pos({\n            type: 'keyframes',\n            name: name,\n            vendor: vendor,\n            keyframes: frames\n        });\n    }\n    function atsupports() {\n        var pos = position();\n        var m = match(/^@supports *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var supports = trim(m[1]);\n        if (!open()) {\n            return error(\"@supports missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@supports missing '}'\");\n        }\n        return pos({\n            type: 'supports',\n            supports: supports,\n            rules: style\n        });\n    }\n    function athost() {\n        var pos = position();\n        var m = match(/^@host\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@host missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@host missing '}'\");\n        }\n        return pos({\n            type: 'host',\n            rules: style\n        });\n    }\n    function atmedia() {\n        var pos = position();\n        var m = match(/^@media *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var media = trim(m[1]);\n        if (!open()) {\n            return error(\"@media missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@media missing '}'\");\n        }\n        return pos({\n            type: 'media',\n            media: media,\n            rules: style\n        });\n    }\n    function atcustommedia() {\n        var pos = position();\n        var m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n        if (!m) {\n            return;\n        }\n        return pos({\n            type: 'custom-media',\n            name: trim(m[1]),\n            media: trim(m[2])\n        });\n    }\n    function atpage() {\n        var pos = position();\n        var m = match(/^@page */);\n        if (!m) {\n            return;\n        }\n        var sel = selector() || [];\n        if (!open()) {\n            return error(\"@page missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@page missing '}'\");\n        }\n        return pos({\n            type: 'page',\n            selectors: sel,\n            declarations: decls\n        });\n    }\n    function atdocument() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?document *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var vendor = trim(m[1]);\n        var doc = trim(m[2]);\n        if (!open()) {\n            return error(\"@document missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@document missing '}'\");\n        }\n        return pos({\n            type: 'document',\n            document: doc,\n            vendor: vendor,\n            rules: style\n        });\n    }\n    function atfontface() {\n        var pos = position();\n        var m = match(/^@font-face\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@font-face missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@font-face missing '}'\");\n        }\n        return pos({\n            type: 'font-face',\n            declarations: decls\n        });\n    }\n    var atimport = _compileAtrule('import');\n    var atcharset = _compileAtrule('charset');\n    var atnamespace = _compileAtrule('namespace');\n    function _compileAtrule(name) {\n        var re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n        return function () {\n            var pos = position();\n            var m = match(re);\n            if (!m) {\n                return;\n            }\n            var ret = { type: name };\n            ret[name] = m[1].trim();\n            return pos(ret);\n        };\n    }\n    function atrule() {\n        if (css[0] !== '@') {\n            return;\n        }\n        return (atkeyframes() ||\n            atmedia() ||\n            atcustommedia() ||\n            atsupports() ||\n            atimport() ||\n            atcharset() ||\n            atnamespace() ||\n            atdocument() ||\n            atpage() ||\n            athost() ||\n            atfontface());\n    }\n    function rule() {\n        var pos = position();\n        var sel = selector();\n        if (!sel) {\n            return error('selector missing');\n        }\n        comments();\n        return pos({\n            type: 'rule',\n            selectors: sel,\n            declarations: declarations()\n        });\n    }\n    return addParent(stylesheet());\n}\nfunction trim(str) {\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\nfunction addParent(obj, parent) {\n    var isNode = obj && typeof obj.type === 'string';\n    var childParent = isNode ? obj : parent;\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var k = _a[_i];\n        var value = obj[k];\n        if (Array.isArray(value)) {\n            value.forEach(function (v) {\n                addParent(v, childParent);\n            });\n        }\n        else if (value && typeof value === 'object') {\n            addParent(value, childParent);\n        }\n    }\n    if (isNode) {\n        Object.defineProperty(obj, 'parent', {\n            configurable: true,\n            writable: true,\n            enumerable: false,\n            value: parent || null\n        });\n    }\n    return obj;\n}\n\nvar tagMap = {\n    script: 'noscript',\n    altglyph: 'altGlyph',\n    altglyphdef: 'altGlyphDef',\n    altglyphitem: 'altGlyphItem',\n    animatecolor: 'animateColor',\n    animatemotion: 'animateMotion',\n    animatetransform: 'animateTransform',\n    clippath: 'clipPath',\n    feblend: 'feBlend',\n    fecolormatrix: 'feColorMatrix',\n    fecomponenttransfer: 'feComponentTransfer',\n    fecomposite: 'feComposite',\n    feconvolvematrix: 'feConvolveMatrix',\n    fediffuselighting: 'feDiffuseLighting',\n    fedisplacementmap: 'feDisplacementMap',\n    fedistantlight: 'feDistantLight',\n    fedropshadow: 'feDropShadow',\n    feflood: 'feFlood',\n    fefunca: 'feFuncA',\n    fefuncb: 'feFuncB',\n    fefuncg: 'feFuncG',\n    fefuncr: 'feFuncR',\n    fegaussianblur: 'feGaussianBlur',\n    feimage: 'feImage',\n    femerge: 'feMerge',\n    femergenode: 'feMergeNode',\n    femorphology: 'feMorphology',\n    feoffset: 'feOffset',\n    fepointlight: 'fePointLight',\n    fespecularlighting: 'feSpecularLighting',\n    fespotlight: 'feSpotLight',\n    fetile: 'feTile',\n    feturbulence: 'feTurbulence',\n    foreignobject: 'foreignObject',\n    glyphref: 'glyphRef',\n    lineargradient: 'linearGradient',\n    radialgradient: 'radialGradient'\n};\nfunction getTagName(n) {\n    var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n    if (tagName === 'link' && n.attributes._cssText) {\n        tagName = 'style';\n    }\n    return tagName;\n}\nfunction escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nvar HOVER_SELECTOR = /([^\\\\]):hover/;\nvar HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\nfunction addHoverClass(cssText, cache) {\n    var cachedStyle = cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.get(cssText);\n    if (cachedStyle)\n        return cachedStyle;\n    var ast = parse(cssText, {\n        silent: true\n    });\n    if (!ast.stylesheet) {\n        return cssText;\n    }\n    var selectors = [];\n    ast.stylesheet.rules.forEach(function (rule) {\n        if ('selectors' in rule) {\n            (rule.selectors || []).forEach(function (selector) {\n                if (HOVER_SELECTOR.test(selector)) {\n                    selectors.push(selector);\n                }\n            });\n        }\n    });\n    if (selectors.length === 0) {\n        return cssText;\n    }\n    var selectorMatcher = new RegExp(selectors\n        .filter(function (selector, index) { return selectors.indexOf(selector) === index; })\n        .sort(function (a, b) { return b.length - a.length; })\n        .map(function (selector) {\n        return escapeRegExp(selector);\n    })\n        .join('|'), 'g');\n    var result = cssText.replace(selectorMatcher, function (selector) {\n        var newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n        return selector + \", \" + newSelector;\n    });\n    cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.set(cssText, result);\n    return result;\n}\nfunction createCache() {\n    var stylesWithHoverClass = new Map();\n    return {\n        stylesWithHoverClass: stylesWithHoverClass\n    };\n}\nfunction buildNode(n, options) {\n    var doc = options.doc, hackCss = options.hackCss, cache = options.cache;\n    switch (n.type) {\n        case NodeType.Document:\n            return doc.implementation.createDocument(null, '', null);\n        case NodeType.DocumentType:\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\n        case NodeType.Element:\n            var tagName = getTagName(n);\n            var node_1;\n            if (n.isSVG) {\n                node_1 = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n            }\n            else {\n                node_1 = doc.createElement(tagName);\n            }\n            var _loop_1 = function (name_1) {\n                if (!n.attributes.hasOwnProperty(name_1)) {\n                    return \"continue\";\n                }\n                var value = n.attributes[name_1];\n                if (tagName === 'option' && name_1 === 'selected' && value === false) {\n                    return \"continue\";\n                }\n                value =\n                    typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n                if (!name_1.startsWith('rr_')) {\n                    var isTextarea = tagName === 'textarea' && name_1 === 'value';\n                    var isRemoteOrDynamicCss = tagName === 'style' && name_1 === '_cssText';\n                    if (isRemoteOrDynamicCss && hackCss) {\n                        value = addHoverClass(value, cache);\n                    }\n                    if (isTextarea || isRemoteOrDynamicCss) {\n                        var child = doc.createTextNode(value);\n                        for (var _i = 0, _a = Array.from(node_1.childNodes); _i < _a.length; _i++) {\n                            var c = _a[_i];\n                            if (c.nodeType === node_1.TEXT_NODE) {\n                                node_1.removeChild(c);\n                            }\n                        }\n                        node_1.appendChild(child);\n                        return \"continue\";\n                    }\n                    try {\n                        if (n.isSVG && name_1 === 'xlink:href') {\n                            node_1.setAttributeNS('http://www.w3.org/1999/xlink', name_1, value);\n                        }\n                        else if (name_1 === 'onload' ||\n                            name_1 === 'onclick' ||\n                            name_1.substring(0, 7) === 'onmouse') {\n                            node_1.setAttribute('_' + name_1, value);\n                        }\n                        else if (tagName === 'meta' &&\n                            n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n                            name_1 === 'content') {\n                            node_1.setAttribute('csp-content', value);\n                            return \"continue\";\n                        }\n                        else if (tagName === 'link' &&\n                            n.attributes.rel === 'preload' &&\n                            n.attributes.as === 'script') {\n                        }\n                        else if (tagName === 'link' &&\n                            n.attributes.rel === 'prefetch' &&\n                            typeof n.attributes.href === 'string' &&\n                            n.attributes.href.endsWith('.js')) {\n                        }\n                        else if (tagName === 'img' &&\n                            n.attributes.srcset &&\n                            n.attributes.rr_dataURL) {\n                            node_1.setAttribute('rrweb-original-srcset', n.attributes.srcset);\n                        }\n                        else {\n                            node_1.setAttribute(name_1, value);\n                        }\n                    }\n                    catch (error) {\n                    }\n                }\n                else {\n                    if (tagName === 'canvas' && name_1 === 'rr_dataURL') {\n                        var image_1 = document.createElement('img');\n                        image_1.src = value;\n                        image_1.onload = function () {\n                            var ctx = node_1.getContext('2d');\n                            if (ctx) {\n                                ctx.drawImage(image_1, 0, 0, image_1.width, image_1.height);\n                            }\n                        };\n                    }\n                    else if (tagName === 'img' && name_1 === 'rr_dataURL') {\n                        var image = node_1;\n                        if (!image.currentSrc.startsWith('data:')) {\n                            image.setAttribute('rrweb-original-src', n.attributes.src);\n                            image.src = value;\n                        }\n                    }\n                    if (name_1 === 'rr_width') {\n                        node_1.style.width = value;\n                    }\n                    else if (name_1 === 'rr_height') {\n                        node_1.style.height = value;\n                    }\n                    else if (name_1 === 'rr_mediaCurrentTime') {\n                        node_1.currentTime = n.attributes\n                            .rr_mediaCurrentTime;\n                    }\n                    else if (name_1 === 'rr_mediaState') {\n                        switch (value) {\n                            case 'played':\n                                node_1\n                                    .play()[\"catch\"](function (e) { return console.warn('media playback error', e); });\n                                break;\n                            case 'paused':\n                                node_1.pause();\n                                break;\n                        }\n                    }\n                }\n            };\n            for (var name_1 in n.attributes) {\n                _loop_1(name_1);\n            }\n            if (n.isShadowHost) {\n                if (!node_1.shadowRoot) {\n                    node_1.attachShadow({ mode: 'open' });\n                }\n                else {\n                    while (node_1.shadowRoot.firstChild) {\n                        node_1.shadowRoot.removeChild(node_1.shadowRoot.firstChild);\n                    }\n                }\n            }\n            return node_1;\n        case NodeType.Text:\n            return doc.createTextNode(n.isStyle && hackCss\n                ? addHoverClass(n.textContent, cache)\n                : n.textContent);\n        case NodeType.CDATA:\n            return doc.createCDATASection(n.textContent);\n        case NodeType.Comment:\n            return doc.createComment(n.textContent);\n        default:\n            return null;\n    }\n}\nfunction buildNodeWithSN(n, options) {\n    var doc = options.doc, map = options.map, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.hackCss, hackCss = _b === void 0 ? true : _b, afterAppend = options.afterAppend, cache = options.cache;\n    var node = buildNode(n, { doc: doc, hackCss: hackCss, cache: cache });\n    if (!node) {\n        return null;\n    }\n    if (n.rootId) {\n        console.assert(map[n.rootId] === doc, 'Target document should has the same root id.');\n    }\n    if (n.type === NodeType.Document) {\n        doc.close();\n        doc.open();\n        if (n.compatMode === 'BackCompat' &&\n            n.childNodes &&\n            n.childNodes[0].type !== NodeType.DocumentType) {\n            if (n.childNodes[0].type === NodeType.Element &&\n                'xmlns' in n.childNodes[0].attributes &&\n                n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\n            }\n            else {\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\n            }\n        }\n        node = doc;\n    }\n    node.__sn = n;\n    map[n.id] = node;\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\n        !skipChild) {\n        for (var _i = 0, _c = n.childNodes; _i < _c.length; _i++) {\n            var childN = _c[_i];\n            var childNode = buildNodeWithSN(childN, {\n                doc: doc,\n                map: map,\n                skipChild: false,\n                hackCss: hackCss,\n                afterAppend: afterAppend,\n                cache: cache\n            });\n            if (!childNode) {\n                console.warn('Failed to rebuild', childN);\n                continue;\n            }\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\n                node.shadowRoot.appendChild(childNode);\n            }\n            else {\n                node.appendChild(childNode);\n            }\n            if (afterAppend) {\n                afterAppend(childNode);\n            }\n        }\n    }\n    return node;\n}\nfunction visit(idNodeMap, onVisit) {\n    function walk(node) {\n        onVisit(node);\n    }\n    for (var key in idNodeMap) {\n        if (idNodeMap[key]) {\n            walk(idNodeMap[key]);\n        }\n    }\n}\nfunction handleScroll(node) {\n    var n = node.__sn;\n    if (n.type !== NodeType.Element) {\n        return;\n    }\n    var el = node;\n    for (var name_2 in n.attributes) {\n        if (!(n.attributes.hasOwnProperty(name_2) && name_2.startsWith('rr_'))) {\n            continue;\n        }\n        var value = n.attributes[name_2];\n        if (name_2 === 'rr_scrollLeft') {\n            el.scrollLeft = value;\n        }\n        if (name_2 === 'rr_scrollTop') {\n            el.scrollTop = value;\n        }\n    }\n}\nfunction rebuild(n, options) {\n    var doc = options.doc, onVisit = options.onVisit, _a = options.hackCss, hackCss = _a === void 0 ? true : _a, afterAppend = options.afterAppend, cache = options.cache;\n    var idNodeMap = {};\n    var node = buildNodeWithSN(n, {\n        doc: doc,\n        map: idNodeMap,\n        skipChild: false,\n        hackCss: hackCss,\n        afterAppend: afterAppend,\n        cache: cache\n    });\n    visit(idNodeMap, function (visitedNode) {\n        if (onVisit) {\n            onVisit(visitedNode);\n        }\n        handleScroll(visitedNode);\n    });\n    return [node, idNodeMap];\n}\n\nexport { IGNORED_NODE, NodeType, addHoverClass, buildNodeWithSN, cleanupSnapshot, createCache, is2DCanvasBlank, isElement, isShadowRoot, maskInputValue, needMaskingText, rebuild, serializeNodeWithId, snapshot, transformAttribute, visitSnapshot };\n","import {\n  serializedNodeWithId,\n  idNodeMap,\n  INode,\n  MaskInputOptions,\n  SlimDOMOptions,\n  MaskInputFn,\n  MaskTextFn,\n} from 'rrweb-snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\nimport { IframeManager } from './record/iframe-manager';\nimport { ShadowDomManager } from './record/shadow-dom-manager';\nimport type { Replayer } from './replay';\nimport { CanvasManager } from './record/observers/canvas/canvas-manager';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n  Plugin,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type pluginEvent<T = unknown> = {\n  type: EventType.Plugin;\n  data: {\n    plugin: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n  CanvasMutation,\n  Font,\n  Log,\n  Drag,\n  StyleDeclaration,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimension;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type styleDeclarationData = {\n  source: IncrementalSource.StyleDeclaration;\n} & styleDeclarationParam;\n\nexport type canvasMutationData = {\n  source: IncrementalSource.CanvasMutation;\n} & canvasMutationParam;\n\nexport type fontData = {\n  source: IncrementalSource.Font;\n} & fontParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData\n  | canvasMutationData\n  | fontData\n  | styleDeclarationData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | customEvent\n  | pluginEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type maskTextClass = string | RegExp;\n\nexport type SamplingStrategy = Partial<{\n  /**\n   * false means not to record mouse/touch move events\n   * number is the throttle threshold of recording mouse/touch move\n   */\n  mousemove: boolean | number;\n  /**\n   * number is the throttle threshold of mouse/touch move callback\n   */\n  mousemoveCallback: number;\n  /**\n   * false means not to record mouse interaction events\n   * can also specify record some kinds of mouse interactions\n   */\n  mouseInteraction: boolean | Record<string, boolean | undefined>;\n  /**\n   * number is the throttle threshold of recording scroll\n   */\n  scroll: number;\n  /**\n   * number is the throttle threshold of recording media interactions\n   */\n  media: number;\n  /**\n   * 'all' will record all the input events\n   * 'last' will only record the last input value while input a sequence of chars\n   */\n  input: 'all' | 'last';\n}>;\n\nexport type RecordPlugin<TOptions = unknown> = {\n  name: string;\n  observer?: (cb: Function, win: IWindow, options: TOptions) => listenerHandler;\n  eventProcessor?: <TExtend>(event: eventWithTime) => eventWithTime & TExtend;\n  options: TOptions;\n};\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  blockSelector?: string;\n  ignoreClass?: string;\n  maskTextClass?: maskTextClass;\n  maskTextSelector?: string;\n  maskAllInputs?: boolean;\n  maskInputOptions?: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  slimDOMOptions?: SlimDOMOptions | 'all' | true;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  packFn?: PackFn;\n  sampling?: SamplingStrategy;\n  recordCanvas?: boolean;\n  userTriggeredOnInput?: boolean;\n  collectFonts?: boolean;\n  inlineImages?: boolean;\n  plugins?: RecordPlugin[];\n  // departed, please use sampling options\n  mousemoveWait?: number;\n  keepIframeSrcFn?: KeepIframeSrcFn;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  blockSelector: string | null;\n  ignoreClass: string;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  maskInputOptions: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  styleDeclarationCb: styleDeclarationCallback;\n  canvasMutationCb: canvasMutationCallback;\n  fontCb: fontCallback;\n  sampling: SamplingStrategy;\n  recordCanvas: boolean;\n  inlineImages: boolean;\n  userTriggeredOnInput: boolean;\n  collectFonts: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  doc: Document;\n  mirror: Mirror;\n  iframeManager: IframeManager;\n  shadowDomManager: ShadowDomManager;\n  canvasManager: CanvasManager;\n  plugins: Array<{\n    observer: Function;\n    callback: Function;\n    options: unknown;\n  }>;\n};\n\nexport type MutationBufferParam = Pick<\n  observerParam,\n  | 'mutationCb'\n  | 'blockClass'\n  | 'blockSelector'\n  | 'maskTextClass'\n  | 'maskTextSelector'\n  | 'inlineStylesheet'\n  | 'maskInputOptions'\n  | 'maskTextFn'\n  | 'maskInputFn'\n  | 'recordCanvas'\n  | 'inlineImages'\n  | 'slimDOMOptions'\n  | 'doc'\n  | 'mirror'\n  | 'iframeManager'\n  | 'shadowDomManager'\n  | 'canvasManager'\n>;\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n  styleDeclaration?: styleDeclarationCallback;\n  canvasMutation?: canvasMutationCallback;\n  font?: fontCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string;\n  target: Node;\n  oldValue: string | null;\n  addedNodes: NodeList;\n  removedNodes: NodeList;\n  attributeName: string | null;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type styleAttributeValue = {\n  [key: string]: styleValueWithPriority | string | false;\n};\n\nexport type styleValueWithPriority = [string, string];\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | styleAttributeValue | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | styleAttributeValue | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n  isShadow?: boolean;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\nexport type mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n  isAttachIframe?: true;\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport type mouseMovePos = {\n  x: number;\n  y: number;\n  id: number;\n  debugData: incrementalData;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n  TouchCancel,\n}\n\nexport enum CanvasContext {\n  '2D',\n  WebGL,\n  WebGL2,\n}\n\nexport type SerializedWebGlArg =\n  | {\n      rr_type: 'ArrayBuffer';\n      base64: string; // base64\n    }\n  | {\n      rr_type: string;\n      src: string; // url of image\n    }\n  | {\n      rr_type: string;\n      args: SerializedWebGlArg[];\n    }\n  | {\n      rr_type: string;\n      index: number;\n    }\n  | string\n  | number\n  | boolean\n  | null\n  | SerializedWebGlArg[];\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number | number[];\n};\n\nexport type styleSheetDeleteRule = {\n  index: number | number[];\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type styleDeclarationParam = {\n  id: number;\n  index: number[];\n  set?: {\n    property: string;\n    value: string | null;\n    priority: string | undefined;\n  };\n  remove?: {\n    property: string;\n  };\n};\n\nexport type styleDeclarationCallback = (s: styleDeclarationParam) => void;\n\nexport type canvasMutationCommand = {\n  property: string;\n  args: Array<unknown>;\n  setter?: true;\n};\n\nexport type canvasMutationParam =\n  | {\n      id: number;\n      type: CanvasContext;\n      commands: canvasMutationCommand[];\n    }\n  | ({\n      id: number;\n      type: CanvasContext;\n    } & canvasMutationCommand);\n\nexport type canvasMutationWithType = {\n  type: CanvasContext;\n} & canvasMutationCommand;\n\nexport type canvasMutationCallback = (p: canvasMutationParam) => void;\n\nexport type canvasManagerMutationCallback = (\n  target: HTMLCanvasElement,\n  p: canvasMutationWithType,\n) => void;\n\nexport type fontParam = {\n  family: string;\n  fontSource: string;\n  buffer: boolean;\n  descriptors?: FontFaceDescriptors;\n};\n\nexport type fontCallback = (p: fontParam) => void;\n\nexport type viewportResizeDimension = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimension) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n\n  // `userTriggered` indicates if this event was triggered directly by user (userTriggered: true)\n  // or was triggered indirectly (userTriggered: false)\n  // Example of `userTriggered` in action:\n  // User clicks on radio element (userTriggered: true) which triggers the other radio element to change (userTriggered: false)\n  userTriggered?: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n  Seeked,\n  VolumeChange,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n  currentTime?: number;\n  volume?: number;\n  muted?: boolean;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type DocumentDimension = {\n  x: number;\n  y: number;\n  // scale value relative to its parent iframe\n  relativeScale: number;\n  // scale value relative to the root iframe\n  absoluteScale: number;\n};\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n  reset: () => void;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type ReplayPlugin = {\n  handler: (\n    event: eventWithTime,\n    isSync: boolean,\n    context: { replayer: Replayer },\n  ) => void;\n};\nexport type playerConfig = {\n  speed: number;\n  maxSpeed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  UNSAFE_replayCanvas: boolean;\n  pauseAnimation?: boolean;\n  mouseTail:\n    | boolean\n    | {\n        duration?: number;\n        lineCap?: string;\n        lineWidth?: number;\n        strokeStyle?: string;\n      };\n  unpackFn?: UnpackFn;\n  plugins?: ReplayPlugin[];\n};\n\nexport type playerMetaData = {\n  startTime: number;\n  endTime: number;\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n  off(type: string, handler: Handler): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n  Flush = 'flush',\n  StateChange = 'state-change',\n  PlayBack = 'play-back',\n}\n\n// store the state that would be changed during the process(unmount from dom and mount again)\nexport type ElementState = {\n  // [scrollLeft,scrollTop]\n  scroll?: [number, number];\n};\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\ndeclare global {\n  interface Window {\n    FontFace: typeof FontFace;\n  }\n}\n\nexport type IWindow = Window & typeof globalThis;\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n  IncrementalSource,\n  addedNodeMutation,\n  removedNodeMutation,\n  textMutation,\n  attributeMutation,\n  mutationData,\n  scrollData,\n  inputData,\n  DocumentDimension,\n  IWindow,\n} from './types';\nimport {\n  INode,\n  IGNORED_NODE,\n  serializedNodeWithId,\n  NodeType,\n  isShadowRoot,\n} from 'rrweb-snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | IWindow = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport function createMirror(): Mirror {\n  return {\n    map: {},\n    getId(n) {\n      // if n is not a serialized INode, use -1 as its id.\n      if (!n || !n.__sn) {\n        return -1;\n      }\n      return n.__sn.id;\n    },\n    getNode(id) {\n      return this.map[id] || null;\n    },\n    // TODO: use a weakmap to get rid of manually memory management\n    removeNodeFromMap(n) {\n      const id = n.__sn && n.__sn.id;\n      delete this.map[id];\n      if (n.childNodes) {\n        n.childNodes.forEach((child) =>\n          this.removeNodeFromMap((child as Node) as INode),\n        );\n      }\n    },\n    has(id) {\n      return this.map.hasOwnProperty(id);\n    },\n    reset() {\n      this.map = {};\n    },\n  };\n}\n\n// https://github.com/rrweb-io/rrweb/pull/407\nconst DEPARTED_MIRROR_ACCESS_WARNING =\n  'Please stop import mirror directly. Instead of that,' +\n  '\\r\\n' +\n  'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\n  '\\r\\n' +\n  'or you can use record.mirror to access the mirror instance during recording.';\nexport let _mirror: Mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n};\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n          set(value) {\n            // put hooked setter into event loop to avoid of set latency\n            setTimeout(() => {\n              d.set!.call(this, value);\n            }, 0);\n            if (original && original.set) {\n              original.set.call(this, value);\n            }\n          },\n        },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\n// copy from https://github.com/getsentry/sentry-javascript/blob/b2109071975af8bf0316d3b5b38f519bdaf5dc15/packages/utils/src/object.ts\nexport function patch(\n  // tslint:disable-next-line:no-any\n  source: { [key: string]: any },\n  name: string,\n  // tslint:disable-next-line:no-any\n  replacement: (...args: any[]) => any,\n): () => void {\n  try {\n    if (!(name in source)) {\n      return () => {};\n    }\n\n    const original = source[name] as () => unknown;\n    const wrapped = replacement(original);\n\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    }\n\n    source[name] = wrapped;\n\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {};\n    // This can throw if multiple fill happens on a global object like XMLHttpRequest\n    // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n  }\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      if ((node as HTMLElement).closest !== undefined) {\n        return (node as HTMLElement).closest('.' + blockClass) !== null;\n      } else {\n        needBlock = (node as HTMLElement).classList.contains(blockClass);\n      }\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isIgnored(n: Node | INode): boolean {\n  if ('__sn' in n) {\n    return (n as INode).__sn.id === IGNORED_NODE;\n  }\n  // The main part of the slimDOM check happens in\n  // rrweb-snapshot::serializeNodeWithId\n  return false;\n}\n\nexport function isAncestorRemoved(target: INode, mirror: Mirror): boolean {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode, mirror);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill(win = window) {\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as DOMTokenList['forEach'];\n  }\n\n  // https://github.com/Financial-Times/polyfill-service/pull/183\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n        // tslint:disable-next-line: no-conditional-assignment\n      } while ((node = node && node.parentNode));\n\n      return false;\n    };\n  }\n}\n\nexport type TreeNode = {\n  id: number;\n  mutation: addedNodeMutation;\n  parent?: TreeNode;\n  children: Record<number, TreeNode>;\n  texts: textMutation[];\n  attributes: attributeMutation[];\n};\nexport class TreeIndex {\n  public tree!: Record<number, TreeNode>;\n\n  private removeNodeMutations!: removedNodeMutation[];\n  private textMutations!: textMutation[];\n  private attributeMutations!: attributeMutation[];\n  private indexes!: Map<number, TreeNode>;\n  private removeIdSet!: Set<number>;\n  private scrollMap!: Map<number, scrollData>;\n  private inputMap!: Map<number, inputData>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public add(mutation: addedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode: TreeNode = {\n      id: mutation.node.id,\n      mutation,\n      children: [],\n      texts: [],\n      attributes: [],\n    };\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n    this.indexes.set(treeNode.id, treeNode);\n  }\n\n  public remove(mutation: removedNodeMutation, mirror: Mirror) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode = this.indexes.get(mutation.id);\n\n    const deepRemoveFromMirror = (id: number) => {\n      this.removeIdSet.add(id);\n      const node = mirror.getNode(id);\n      node?.childNodes.forEach((childNode) => {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(((childNode as unknown) as INode).__sn.id);\n        }\n      });\n    };\n    const deepRemoveFromTreeIndex = (node: TreeNode) => {\n      this.removeIdSet.add(node.id);\n      Object.values(node.children).forEach((n) => deepRemoveFromTreeIndex(n));\n      const _treeNode = this.indexes.get(node.id);\n      if (_treeNode) {\n        const _parentTreeNode = _treeNode.parent;\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n          this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  }\n\n  public text(mutation: textMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  }\n\n  public attribute(mutation: attributeMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  }\n\n  public scroll(d: scrollData) {\n    this.scrollMap.set(d.id, d);\n  }\n\n  public input(d: inputData) {\n    this.inputMap.set(d.id, d);\n  }\n\n  public flush(): {\n    mutationData: mutationData;\n    scrollMap: TreeIndex['scrollMap'];\n    inputMap: TreeIndex['inputMap'];\n  } {\n    const {\n      tree,\n      removeNodeMutations,\n      textMutations,\n      attributeMutations,\n    } = this;\n\n    const batchMutationData: mutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: [],\n    };\n\n    const walk = (treeNode: TreeNode, removed: boolean) => {\n      if (removed) {\n        this.removeIdSet.add(treeNode.id);\n      }\n      batchMutationData.texts = batchMutationData.texts\n        .concat(removed ? [] : treeNode.texts)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      batchMutationData.attributes = batchMutationData.attributes\n        .concat(removed ? [] : treeNode.attributes)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      if (\n        !this.removeIdSet.has(treeNode.id) &&\n        !this.removeIdSet.has(treeNode.mutation.parentId) &&\n        !removed\n      ) {\n        batchMutationData.adds.push(treeNode.mutation);\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach((n) => walk(n, false));\n        }\n      } else {\n        Object.values(treeNode.children).forEach((n) => walk(n, true));\n      }\n    };\n\n    Object.values(tree).forEach((n) => walk(n, false));\n\n    for (const id of this.scrollMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.scrollMap.delete(id);\n      }\n    }\n    for (const id of this.inputMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.inputMap.delete(id);\n      }\n    }\n\n    const scrollMap = new Map(this.scrollMap);\n    const inputMap = new Map(this.inputMap);\n\n    this.reset();\n\n    return {\n      mutationData: batchMutationData,\n      scrollMap,\n      inputMap,\n    };\n  }\n\n  private reset() {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  }\n\n  public idRemoved(id: number): boolean {\n    return this.removeIdSet.has(id);\n  }\n}\n\ntype ResolveTree = {\n  value: addedNodeMutation;\n  children: ResolveTree[];\n  parent: ResolveTree | null;\n};\n\nexport function queueToResolveTrees(queue: addedNodeMutation[]): ResolveTree[] {\n  const queueNodeMap: Record<number, ResolveTree> = {};\n  const putIntoMap = (\n    m: addedNodeMutation,\n    parent: ResolveTree | null,\n  ): ResolveTree => {\n    const nodeInTree: ResolveTree = {\n      value: m,\n      parent,\n      children: [],\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  const queueNodeTrees: ResolveTree[] = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent),\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n\n  return queueNodeTrees;\n}\n\nexport function iterateResolveTree(\n  tree: ResolveTree,\n  cb: (mutation: addedNodeMutation) => unknown,\n) {\n  cb(tree.value);\n  /**\n   * The resolve tree was designed to reflect the DOM layout,\n   * but we need append next sibling first, so we do a reverse\n   * loop here.\n   */\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\ntype HTMLIFrameINode = HTMLIFrameElement & {\n  __sn: serializedNodeWithId;\n};\nexport type AppendedIframe = {\n  mutationInQueue: addedNodeMutation;\n  builtNode: HTMLIFrameINode;\n};\n\nexport function isIframeINode(\n  node: INode | ShadowRoot,\n): node is HTMLIFrameINode {\n  if ('__sn' in node) {\n    return (\n      node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe'\n    );\n  }\n  // node can be document fragment when using the virtual parent feature\n  return false;\n}\n\nexport function getBaseDimension(\n  node: Node,\n  rootIframe: Node,\n): DocumentDimension {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1,\n    };\n  }\n\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  // the iframe element may have a scale transform\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x:\n      frameDimension.x * frameBaseDimension.relativeScale +\n      frameBaseDimension.x,\n    y:\n      frameDimension.y * frameBaseDimension.relativeScale +\n      frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\n  };\n}\n\nexport function hasShadowRoot<T extends Node>(\n  n: T,\n): n is T & { shadowRoot: ShadowRoot } {\n  return Boolean(((n as unknown) as Element)?.shadowRoot);\n}\n","import {\n  INode,\n  serializeNodeWithId,\n  transformAttribute,\n  IGNORED_NODE,\n  isShadowRoot,\n  needMaskingText,\n  maskInputValue,\n} from 'rrweb-snapshot';\nimport {\n  mutationRecord,\n  textCursor,\n  attributeCursor,\n  removedNodeMutation,\n  addedNodeMutation,\n  Mirror,\n  styleAttributeValue,\n  observerParam,\n  MutationBufferParam,\n  Optional,\n} from '../types';\nimport {\n  isBlocked,\n  isAncestorRemoved,\n  isIgnored,\n  isIframeINode,\n  hasShadowRoot,\n} from '../utils';\n\ntype DoubleLinkedListNode = {\n  previous: DoubleLinkedListNode | null;\n  next: DoubleLinkedListNode | null;\n  value: NodeInLinkedList;\n};\ntype NodeInLinkedList = Node & {\n  __ln: DoubleLinkedListNode;\n};\n\nfunction isNodeInLinkedList(n: Node | NodeInLinkedList): n is NodeInLinkedList {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  public length = 0;\n  public head: DoubleLinkedListNode | null = null;\n\n  public get(position: number) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n\n  public addNode(n: Node) {\n    const node: DoubleLinkedListNode = {\n      value: n as NodeInLinkedList,\n      previous: null,\n      next: null,\n    };\n    (n as NodeInLinkedList).__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (\n      n.nextSibling &&\n      isNodeInLinkedList(n.nextSibling) &&\n      n.nextSibling.__ln.previous\n    ) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    this.length++;\n  }\n\n  public removeNode(n: NodeInLinkedList) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n    if (n.__ln) {\n      delete (n as Optional<NodeInLinkedList, '__ln'>).__ln;\n    }\n    this.length--;\n  }\n}\n\nconst moveKey = (id: number, parentId: number) => `${id}@${parentId}`;\nfunction isINode(n: Node | INode): n is INode {\n  return '__sn' in n;\n}\n\n/**\n * controls behaviour of a MutationObserver\n */\nexport default class MutationBuffer {\n  private frozen: boolean = false;\n  private locked: boolean = false;\n\n  private texts: textCursor[] = [];\n  private attributes: attributeCursor[] = [];\n  private removes: removedNodeMutation[] = [];\n  private mapRemoves: Node[] = [];\n\n  private movedMap: Record<string, true> = {};\n\n  /**\n   * the browser MutationObserver emits multiple mutations after\n   * a delay for performance reasons, making tracing added nodes hard\n   * in our `processMutations` callback function.\n   * For example, if we append an element el_1 into body, and then append\n   * another element el_2 into el_1, these two mutations may be passed to the\n   * callback function together when the two operations were done.\n   * Generally we need to trace child nodes of newly added nodes, but in this\n   * case if we count el_2 as el_1's child node in the first mutation record,\n   * then we will count el_2 again in the second mutation record which was\n   * duplicated.\n   * To avoid of duplicate counting added nodes, we use a Set to store\n   * added nodes and its child nodes during iterate mutation records. Then\n   * collect added nodes from the Set which have no duplicate copy. But\n   * this also causes newly added nodes will not be serialized with id ASAP,\n   * which means all the id related calculation should be lazy too.\n   */\n  private addedSet = new Set<Node>();\n  private movedSet = new Set<Node>();\n  private droppedSet = new Set<Node>();\n\n  private mutationCb: observerParam['mutationCb'];\n  private blockClass: observerParam['blockClass'];\n  private blockSelector: observerParam['blockSelector'];\n  private maskTextClass: observerParam['maskTextClass'];\n  private maskTextSelector: observerParam['maskTextSelector'];\n  private inlineStylesheet: observerParam['inlineStylesheet'];\n  private maskInputOptions: observerParam['maskInputOptions'];\n  private maskTextFn: observerParam['maskTextFn'];\n  private maskInputFn: observerParam['maskInputFn'];\n  private recordCanvas: observerParam['recordCanvas'];\n  private inlineImages: observerParam['inlineImages'];\n  private slimDOMOptions: observerParam['slimDOMOptions'];\n  private doc: observerParam['doc'];\n  private mirror: observerParam['mirror'];\n  private iframeManager: observerParam['iframeManager'];\n  private shadowDomManager: observerParam['shadowDomManager'];\n  private canvasManager: observerParam['canvasManager'];\n\n  public init(options: MutationBufferParam) {\n    ([\n      'mutationCb',\n      'blockClass',\n      'blockSelector',\n      'maskTextClass',\n      'maskTextSelector',\n      'inlineStylesheet',\n      'maskInputOptions',\n      'maskTextFn',\n      'maskInputFn',\n      'recordCanvas',\n      'inlineImages',\n      'slimDOMOptions',\n      'doc',\n      'mirror',\n      'iframeManager',\n      'shadowDomManager',\n      'canvasManager',\n    ] as const).forEach((key) => {\n      // just a type trick, the runtime result is correct\n      this[key] = options[key] as never;\n    });\n  }\n\n  public freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n\n  public unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n\n  public isFrozen() {\n    return this.frozen;\n  }\n\n  public lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n\n  public unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n\n  public reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation); // adds mutations to the buffer\n    this.emit(); // clears buffer if not locked/frozen\n  };\n\n  public emit = () => {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    // delay any modification of the mirror until this function\n    // so that the mirror for takeFullSnapshot doesn't get mutated while it's event is being processed\n\n    const adds: addedNodeMutation[] = [];\n\n    /**\n     * Sometimes child node may be pushed before its newly added\n     * parent, so we init a queue to store these nodes.\n     */\n    const addList = new DoubleLinkedList();\n    const getNextId = (n: Node): number | null => {\n      let ns: Node | null = n;\n      let nextId: number | null = IGNORED_NODE; // slimDOM: ignored\n      while (nextId === IGNORED_NODE) {\n        ns = ns && ns.nextSibling;\n        nextId = ns && this.mirror.getId((ns as unknown) as INode);\n      }\n      return nextId;\n    };\n    const pushAdd = (n: Node) => {\n      const shadowHost: Element | null = n.getRootNode\n        ? (n.getRootNode() as ShadowRoot)?.host\n        : null;\n      // If n is in a nested shadow dom.\n      let rootShadowHost = shadowHost;\n      while ((rootShadowHost?.getRootNode?.() as ShadowRoot | undefined)?.host)\n        rootShadowHost =\n          (rootShadowHost?.getRootNode?.() as ShadowRoot | undefined)?.host ||\n          null;\n      // ensure shadowHost is a Node, or doc.contains will throw an error\n      const notInDoc =\n        !this.doc.contains(n) &&\n        (rootShadowHost === null || !this.doc.contains(rootShadowHost));\n      if (!n.parentNode || notInDoc) {\n        return;\n      }\n      const parentId = isShadowRoot(n.parentNode)\n        ? this.mirror.getId((shadowHost as unknown) as INode)\n        : this.mirror.getId((n.parentNode as Node) as INode);\n      const nextId = getNextId(n);\n      if (parentId === -1 || nextId === -1) {\n        return addList.addNode(n);\n      }\n      let sn = serializeNodeWithId(n, {\n        doc: this.doc,\n        map: this.mirror.map,\n        blockClass: this.blockClass,\n        blockSelector: this.blockSelector,\n        maskTextClass: this.maskTextClass,\n        maskTextSelector: this.maskTextSelector,\n        skipChild: true,\n        inlineStylesheet: this.inlineStylesheet,\n        maskInputOptions: this.maskInputOptions,\n        maskTextFn: this.maskTextFn,\n        maskInputFn: this.maskInputFn,\n        slimDOMOptions: this.slimDOMOptions,\n        recordCanvas: this.recordCanvas,\n        inlineImages: this.inlineImages,\n        onSerialize: (currentN) => {\n          if (isIframeINode(currentN)) {\n            this.iframeManager.addIframe(currentN);\n          }\n          if (hasShadowRoot(n)) {\n            this.shadowDomManager.addShadowRoot(n.shadowRoot, document);\n          }\n        },\n        onIframeLoad: (iframe, childSn) => {\n          this.iframeManager.attachIframe(iframe, childSn);\n          this.shadowDomManager.observeAttachShadow(\n            (iframe as Node) as HTMLIFrameElement,\n          );\n        },\n      });\n      if (sn) {\n        adds.push({\n          parentId,\n          nextId,\n          node: sn,\n        });\n      }\n    };\n\n    while (this.mapRemoves.length) {\n      this.mirror.removeNodeFromMap(this.mapRemoves.shift() as INode);\n    }\n\n    for (const n of this.movedSet) {\n      if (\n        isParentRemoved(this.removes, n, this.mirror) &&\n        !this.movedSet.has(n.parentNode!)\n      ) {\n        continue;\n      }\n      pushAdd(n);\n    }\n\n    for (const n of this.addedSet) {\n      if (\n        !isAncestorInSet(this.droppedSet, n) &&\n        !isParentRemoved(this.removes, n, this.mirror)\n      ) {\n        pushAdd(n);\n      } else if (isAncestorInSet(this.movedSet, n)) {\n        pushAdd(n);\n      } else {\n        this.droppedSet.add(n);\n      }\n    }\n\n    let candidate: DoubleLinkedListNode | null = null;\n    while (addList.length) {\n      let node: DoubleLinkedListNode | null = null;\n      if (candidate) {\n        const parentId = this.mirror.getId(\n          (candidate.value.parentNode as Node) as INode,\n        );\n        const nextId = getNextId(candidate.value);\n        if (parentId !== -1 && nextId !== -1) {\n          node = candidate;\n        }\n      }\n      if (!node) {\n        for (let index = addList.length - 1; index >= 0; index--) {\n          const _node = addList.get(index)!;\n          // ensure _node is defined before attempting to find value\n          if (_node) {\n            const parentId = this.mirror.getId(\n              (_node.value.parentNode as Node) as INode,\n            );\n            const nextId = getNextId(_node.value);\n            if (parentId !== -1 && nextId !== -1) {\n              node = _node;\n              break;\n            }\n          }\n        }\n      }\n      if (!node) {\n        /**\n         * If all nodes in queue could not find a serialized parent,\n         * it may be a bug or corner case. We need to escape the\n         * dead while loop at once.\n         */\n        while (addList.head) {\n          addList.removeNode(addList.head.value);\n        }\n        break;\n      }\n      candidate = node.previous;\n      addList.removeNode(node.value);\n      pushAdd(node.value);\n    }\n\n    const payload = {\n      texts: this.texts\n        .map((text) => ({\n          id: this.mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter((text) => this.mirror.has(text.id)),\n      attributes: this.attributes\n        .map((attribute) => ({\n          id: this.mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter((attribute) => this.mirror.has(attribute.id)),\n      removes: this.removes,\n      adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n\n    // reset\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.addedSet = new Set<Node>();\n    this.movedSet = new Set<Node>();\n    this.droppedSet = new Set<Node>();\n    this.movedMap = {};\n\n    this.mutationCb(payload);\n  };\n\n  private processMutation = (m: mutationRecord) => {\n    if (isIgnored(m.target)) {\n      return;\n    }\n    switch (m.type) {\n      case 'characterData': {\n        const value = m.target.textContent;\n        if (!isBlocked(m.target, this.blockClass) && value !== m.oldValue) {\n          this.texts.push({\n            value:\n              needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n              ) && value\n                ? this.maskTextFn\n                  ? this.maskTextFn(value)\n                  : value.replace(/[\\S]/g, '*')\n                : value,\n            node: m.target,\n          });\n        }\n        break;\n      }\n      case 'attributes': {\n        const target = m.target as HTMLElement;\n        let value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        if (m.attributeName === 'value') {\n          value = maskInputValue({\n            maskInputOptions: this.maskInputOptions,\n            tagName: (m.target as HTMLElement).tagName,\n            type: (m.target as HTMLElement).getAttribute('type'),\n            value,\n            maskInputFn: this.maskInputFn,\n          });\n        }\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        let item: attributeCursor | undefined = this.attributes.find(\n          (a) => a.node === m.target,\n        );\n        if (!item) {\n          item = {\n            node: m.target,\n            attributes: {},\n          };\n          this.attributes.push(item);\n        }\n        if (m.attributeName === 'style') {\n          const old = this.doc.createElement('span');\n          if (m.oldValue) {\n            old.setAttribute('style', m.oldValue);\n          }\n          if (\n            item.attributes.style === undefined ||\n            item.attributes.style === null\n          ) {\n            item.attributes.style = {};\n          }\n          const styleObj = item.attributes.style as styleAttributeValue;\n          for (const pname of Array.from(target.style)) {\n            const newValue = target.style.getPropertyValue(pname);\n            const newPriority = target.style.getPropertyPriority(pname);\n            if (\n              newValue !== old.style.getPropertyValue(pname) ||\n              newPriority !== old.style.getPropertyPriority(pname)\n            ) {\n              if (newPriority === '') {\n                styleObj[pname] = newValue;\n              } else {\n                styleObj[pname] = [newValue, newPriority];\n              }\n            }\n          }\n          for (const pname of Array.from(old.style)) {\n            if (target.style.getPropertyValue(pname) === '') {\n              // \"if not set, returns the empty string\"\n              styleObj[pname] = false; // delete\n            }\n          }\n        } else {\n          // overwrite attribute if the mutations was triggered in same time\n          item.attributes[m.attributeName!] = transformAttribute(\n            this.doc,\n            (m.target as HTMLElement).tagName,\n            m.attributeName!,\n            value!,\n          );\n        }\n        break;\n      }\n      case 'childList': {\n        m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n        m.removedNodes.forEach((n) => {\n          const nodeId = this.mirror.getId(n as INode);\n          const parentId = isShadowRoot(m.target)\n            ? this.mirror.getId((m.target.host as unknown) as INode)\n            : this.mirror.getId(m.target as INode);\n          if (isBlocked(m.target, this.blockClass) || isIgnored(n)) {\n            return;\n          }\n          // removed node has not been serialized yet, just remove it from the Set\n          if (this.addedSet.has(n)) {\n            deepDelete(this.addedSet, n);\n            this.droppedSet.add(n);\n          } else if (this.addedSet.has(m.target) && nodeId === -1) {\n            /**\n             * If target was newly added and removed child node was\n             * not serialized, it means the child node has been removed\n             * before callback fired, so we can ignore it because\n             * newly added node will be serialized without child nodes.\n             * TODO: verify this\n             */\n          } else if (isAncestorRemoved(m.target as INode, this.mirror)) {\n            /**\n             * If parent id was not in the mirror map any more, it\n             * means the parent node has already been removed. So\n             * the node is also removed which we do not need to track\n             * and replay.\n             */\n          } else if (\n            this.movedSet.has(n) &&\n            this.movedMap[moveKey(nodeId, parentId)]\n          ) {\n            deepDelete(this.movedSet, n);\n          } else {\n            this.removes.push({\n              parentId,\n              id: nodeId,\n              isShadow: isShadowRoot(m.target) ? true : undefined,\n            });\n          }\n          this.mapRemoves.push(n);\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  private genAdds = (n: Node | INode, target?: Node | INode) => {\n    // parent was blocked, so we can ignore this node\n    if (target && isBlocked(target, this.blockClass)) {\n      return;\n    }\n    if (isINode(n)) {\n      if (isIgnored(n)) {\n        return;\n      }\n      this.movedSet.add(n);\n      let targetId: number | null = null;\n      if (target && isINode(target)) {\n        targetId = target.__sn.id;\n      }\n      if (targetId) {\n        this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n      }\n    } else {\n      this.addedSet.add(n);\n      this.droppedSet.delete(n);\n    }\n\n    // if this node is blocked `serializeNode` will turn it into a placeholder element\n    // but we have to remove it's children otherwise they will be added as placeholders too\n    if (!isBlocked(n, this.blockClass))\n      n.childNodes.forEach((childN) => this.genAdds(childN));\n  };\n}\n\n/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\nfunction deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\n\nfunction isParentRemoved(\n  removes: removedNodeMutation[],\n  n: Node,\n  mirror: Mirror,\n): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some((r) => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode, mirror);\n}\n\nfunction isAncestorInSet(set: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return isAncestorInSet(set, parentNode);\n}\n","import { INode, MaskInputOptions, maskInputValue } from 'rrweb-snapshot';\nimport { FontFaceSet } from 'css-font-loading-module';\nimport {\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isTouchEvent,\n  patch,\n} from '../utils';\nimport {\n  mutationCallBack,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  styleSheetRuleCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  IncrementalSource,\n  hooksParam,\n  Arguments,\n  mediaInteractionCallback,\n  MediaInteractions,\n  canvasMutationCallback,\n  fontCallback,\n  fontParam,\n  styleDeclarationCallback,\n  IWindow,\n  MutationBufferParam,\n} from '../types';\nimport MutationBuffer from './mutation';\n\ntype WindowWithStoredMutationObserver = IWindow & {\n  __rrMutationObserver?: MutationObserver;\n};\ntype WindowWithAngularZone = IWindow & {\n  Zone?: {\n    __symbol__?: (key: string) => string;\n  };\n};\n\nexport const mutationBuffers: MutationBuffer[] = [];\n\nconst isCSSGroupingRuleSupported = typeof CSSGroupingRule !== 'undefined';\nconst isCSSMediaRuleSupported = typeof CSSMediaRule !== 'undefined';\nconst isCSSSupportsRuleSupported = typeof CSSSupportsRule !== 'undefined';\nconst isCSSConditionRuleSupported = typeof CSSConditionRule !== 'undefined';\n\n// Event.path is non-standard and used in some older browsers\ntype NonStandardEvent = Omit<Event, 'composedPath'> & {\n  path: EventTarget[];\n};\n\nfunction getEventTarget(event: Event | NonStandardEvent): EventTarget | null {\n  try {\n    if ('composedPath' in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if ('path' in event && event.path.length) {\n      return event.path[0];\n    }\n    return event.target;\n  } catch {\n    return event.target;\n  }\n}\n\nexport function initMutationObserver(\n  options: MutationBufferParam,\n  rootEl: Node,\n): MutationObserver {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  // see mutation.ts for details\n  mutationBuffer.init(options);\n  let mutationObserverCtor =\n    window.MutationObserver ||\n    /**\n     * Some websites may disable MutationObserver by removing it from the window object.\n     * If someone is using rrweb to build a browser extention or things like it, they\n     * could not change the website's code but can have an opportunity to inject some\n     * code before the website executing its JS logic.\n     * Then they can do this to store the native MutationObserver:\n     * window.__rrMutationObserver = MutationObserver\n     */\n    (window as WindowWithStoredMutationObserver).__rrMutationObserver;\n  const angularZoneSymbol = (window as WindowWithAngularZone)?.Zone?.__symbol__?.(\n    'MutationObserver',\n  );\n  if (\n    angularZoneSymbol &&\n    ((window as unknown) as Record<string, typeof MutationObserver>)[\n      angularZoneSymbol\n    ]\n  ) {\n    mutationObserverCtor = ((window as unknown) as Record<\n      string,\n      typeof MutationObserver\n    >)[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    mutationBuffer.processMutations.bind(mutationBuffer),\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror,\n}: observerParam): listenerHandler {\n  if (sampling.mousemove === false) {\n    return () => {};\n  }\n\n  const threshold =\n    typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  const callbackThreshold =\n    typeof sampling.mousemoveCallback === 'number'\n      ? sampling.mousemoveCallback\n      : 500;\n\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle(\n    (\n      source:\n        | IncrementalSource.MouseMove\n        | IncrementalSource.TouchMove\n        | IncrementalSource.Drag,\n    ) => {\n      const totalOffset = Date.now() - timeBaseline!;\n      mousemoveCb(\n        positions.map((p) => {\n          p.timeOffset -= totalOffset;\n          return p;\n        }),\n        source,\n      );\n      positions = [];\n      timeBaseline = null;\n    },\n    callbackThreshold,\n  );\n  const updatePosition = throttle<MouseEvent | TouchEvent | DragEvent>(\n    (evt) => {\n      const target = getEventTarget(evt);\n      const { clientX, clientY } = isTouchEvent(evt)\n        ? evt.changedTouches[0]\n        : evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      // it is possible DragEvent is undefined even on devices\n      // that support event 'drag'\n      wrappedCb(\n        typeof DragEvent !== 'undefined' && evt instanceof DragEvent\n          ? IncrementalSource.Drag\n          : evt instanceof MouseEvent\n          ? IncrementalSource.MouseMove\n          : IncrementalSource.TouchMove,\n      );\n    },\n    threshold,\n    {\n      trailing: false,\n    },\n  );\n  const handlers = [\n    on('mousemove', updatePosition, doc),\n    on('touchmove', updatePosition, doc),\n    on('drag', updatePosition, doc),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror,\n  blockClass,\n  sampling,\n}: observerParam): listenerHandler {\n  if (sampling.mouseInteraction === false) {\n    return () => {};\n  }\n  const disableMap: Record<string, boolean | undefined> =\n    sampling.mouseInteraction === true ||\n    sampling.mouseInteraction === undefined\n      ? {}\n      : sampling.mouseInteraction;\n\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent | TouchEvent) => {\n      const target = getEventTarget(event) as Node;\n      if (isBlocked(target as Node, blockClass)) {\n        return;\n      }\n      const e = isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e) {\n        return;\n      }\n      const id = mirror.getId(target as INode);\n      const { clientX, clientY } = e;\n      mouseInteractionCb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(\n      (key) =>\n        Number.isNaN(Number(key)) &&\n        !key.endsWith('_Departed') &&\n        disableMap[key] !== false,\n    )\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler, doc));\n    });\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nexport function initScrollObserver({\n  scrollCb,\n  doc,\n  mirror,\n  blockClass,\n  sampling,\n}: Pick<\n  observerParam,\n  'scrollCb' | 'doc' | 'mirror' | 'blockClass' | 'sampling'\n>): listenerHandler {\n  const updatePosition = throttle<UIEvent>((evt) => {\n    const target = getEventTarget(evt);\n    if (!target || isBlocked(target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(target as INode);\n    if (target === doc) {\n      const scrollEl = (doc.scrollingElement || doc.documentElement)!;\n      scrollCb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      scrollCb({\n        id,\n        x: (target as HTMLElement).scrollLeft,\n        y: (target as HTMLElement).scrollTop,\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition, doc);\n}\n\nfunction initViewportResizeObserver({\n  viewportResizeCb,\n}: observerParam): listenerHandler {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    if (lastH !== height || lastW !== width) {\n      viewportResizeCb({\n        width: Number(width),\n        height: Number(height),\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nfunction wrapEventWithUserTriggeredFlag(\n  v: inputValue,\n  enable: boolean,\n): inputValue {\n  const value = { ...v };\n  if (!enable) delete value.userTriggered;\n  return value;\n}\n\nexport const INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror,\n  blockClass,\n  ignoreClass,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n}: observerParam): listenerHandler {\n  function eventHandler(event: Event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    /**\n     * If a site changes the value 'selected' of an option element, the value of its parent element, usually a select element, will be changed as well.\n     * We can treat this change as a value change of the select element the current target belongs to.\n     */\n    if (target && (target as Element).tagName === 'OPTION')\n      target = (target as Element).parentElement;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if ((target as HTMLElement).classList.contains(ignoreClass)) {\n      return;\n    }\n    let text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    } else if (\n      maskInputOptions[\n        (target as Element).tagName.toLowerCase() as keyof MaskInputOptions\n      ] ||\n      maskInputOptions[type as keyof MaskInputOptions]\n    ) {\n      text = maskInputValue({\n        maskInputOptions,\n        tagName: (target as HTMLElement).tagName,\n        type,\n        value: text,\n        maskInputFn,\n      });\n    }\n    cbWithDedup(\n      target,\n      wrapEventWithUserTriggeredFlag(\n        { text, isChecked, userTriggered },\n        userTriggeredOnInput,\n      ),\n    );\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      doc\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach((el) => {\n          if (el !== target) {\n            cbWithDedup(\n              el,\n              wrapEventWithUserTriggeredFlag(\n                {\n                  text: (el as HTMLInputElement).value,\n                  isChecked: !isChecked,\n                  userTriggered: false,\n                },\n                userTriggeredOnInput,\n              ),\n            );\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      inputCb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  const handlers: Array<\n    listenerHandler | hookResetter\n  > = events.map((eventName) => on(eventName, eventHandler, doc));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n    // Some UI library use selectedIndex to set select value\n    [HTMLSelectElement.prototype, 'selectedIndex'],\n    [HTMLOptionElement.prototype, 'selected'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map((p) =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\ntype GroupingCSSRule =\n  | CSSGroupingRule\n  | CSSMediaRule\n  | CSSSupportsRule\n  | CSSConditionRule;\ntype GroupingCSSRuleTypes =\n  | typeof CSSGroupingRule\n  | typeof CSSMediaRule\n  | typeof CSSSupportsRule\n  | typeof CSSConditionRule;\n\nfunction getNestedCSSRulePositions(rule: CSSRule): number[] {\n  const positions: number[] = [];\n  function recurse(childRule: CSSRule, pos: number[]) {\n    if (\n      (isCSSGroupingRuleSupported &&\n        childRule.parentRule instanceof CSSGroupingRule) ||\n      (isCSSMediaRuleSupported &&\n        childRule.parentRule instanceof CSSMediaRule) ||\n      (isCSSSupportsRuleSupported &&\n        childRule.parentRule instanceof CSSSupportsRule) ||\n      (isCSSConditionRuleSupported &&\n        childRule.parentRule instanceof CSSConditionRule)\n    ) {\n      const rules = Array.from(\n        (childRule.parentRule as GroupingCSSRule).cssRules,\n      );\n      const index = rules.indexOf(childRule);\n      pos.unshift(index);\n    } else {\n      const rules = Array.from(childRule.parentStyleSheet!.cssRules);\n      const index = rules.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\n\nfunction initStyleSheetObserver(\n  { styleSheetRuleCb, mirror }: observerParam,\n  { win }: { win: IWindow },\n): listenerHandler {\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = function (\n    rule: string,\n    index?: number,\n  ) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      styleSheetRuleCb({\n        id,\n        adds: [{ rule, index }],\n      });\n    }\n    return insertRule.apply(this, arguments);\n  };\n\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = function (index: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      styleSheetRuleCb({\n        id,\n        removes: [{ index }],\n      });\n    }\n    return deleteRule.apply(this, arguments);\n  };\n\n  const supportedNestedCSSRuleTypes: {\n    [key: string]: GroupingCSSRuleTypes;\n  } = {};\n  if (isCSSGroupingRuleSupported) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    // Some browsers (Safari) don't support CSSGroupingRule\n    // https://caniuse.com/?search=cssgroupingrule\n    // fall back to monkey patching classes that would have inherited from CSSGroupingRule\n\n    if (isCSSMediaRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (isCSSConditionRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (isCSSSupportsRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n\n  const unmodifiedFunctions: {\n    [key: string]: {\n      insertRule: (rule: string, index?: number) => number;\n      deleteRule: (index: number) => void;\n    };\n  } = {};\n\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      insertRule: (type as GroupingCSSRuleTypes).prototype.insertRule,\n      deleteRule: (type as GroupingCSSRuleTypes).prototype.deleteRule,\n    };\n\n    type.prototype.insertRule = function (rule: string, index?: number) {\n      const id = mirror.getId(this.parentStyleSheet.ownerNode as INode);\n      if (id !== -1) {\n        styleSheetRuleCb({\n          id,\n          adds: [\n            {\n              rule,\n              index: [\n                ...getNestedCSSRulePositions(this),\n                index || 0, // defaults to 0\n              ],\n            },\n          ],\n        });\n      }\n      return unmodifiedFunctions[typeKey].insertRule.apply(this, arguments);\n    };\n\n    type.prototype.deleteRule = function (index: number) {\n      const id = mirror.getId(this.parentStyleSheet.ownerNode as INode);\n      if (id !== -1) {\n        styleSheetRuleCb({\n          id,\n          removes: [{ index: [...getNestedCSSRulePositions(this), index] }],\n        });\n      }\n      return unmodifiedFunctions[typeKey].deleteRule.apply(this, arguments);\n    };\n  });\n\n  return () => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  };\n}\n\nfunction initStyleDeclarationObserver(\n  { styleDeclarationCb, mirror }: observerParam,\n  { win }: { win: IWindow },\n): listenerHandler {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = function (\n    this: CSSStyleDeclaration,\n    property: string,\n    value: string,\n    priority: string,\n  ) {\n    const id = mirror.getId(\n      (this.parentRule?.parentStyleSheet?.ownerNode as unknown) as INode,\n    );\n    if (id !== -1) {\n      styleDeclarationCb({\n        id,\n        set: {\n          property,\n          value,\n          priority,\n        },\n        index: getNestedCSSRulePositions(this.parentRule!),\n      });\n    }\n    return setProperty.apply(this, arguments);\n  };\n\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = function (\n    this: CSSStyleDeclaration,\n    property: string,\n  ) {\n    const id = mirror.getId(\n      (this.parentRule?.parentStyleSheet?.ownerNode as unknown) as INode,\n    );\n    if (id !== -1) {\n      styleDeclarationCb({\n        id,\n        remove: {\n          property,\n        },\n        index: getNestedCSSRulePositions(this.parentRule!),\n      });\n    }\n    return removeProperty.apply(this, arguments);\n  };\n\n  return () => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  };\n}\n\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  mirror,\n  sampling,\n}: observerParam): listenerHandler {\n  const handler = (type: MediaInteractions) =>\n    throttle((event: Event) => {\n      const target = getEventTarget(event);\n      if (!target || isBlocked(target as Node, blockClass)) {\n        return;\n      }\n      const { currentTime, volume, muted } = target as HTMLMediaElement;\n      mediaInteractionCb({\n        type,\n        id: mirror.getId(target as INode),\n        currentTime,\n        volume,\n        muted,\n      });\n    }, sampling.media || 500);\n  const handlers = [\n    on('play', handler(MediaInteractions.Play)),\n    on('pause', handler(MediaInteractions.Pause)),\n    on('seeked', handler(MediaInteractions.Seeked)),\n    on('volumechange', handler(MediaInteractions.VolumeChange)),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initFontObserver({ fontCb, doc }: observerParam): listenerHandler {\n  const win = doc.defaultView as IWindow;\n  if (!win) {\n    return () => {};\n  }\n\n  const handlers: listenerHandler[] = [];\n\n  const fontMap = new WeakMap<FontFace, fontParam>();\n\n  const originalFontFace = win.FontFace;\n  win.FontFace = (function FontFace(\n    family: string,\n    source: string | ArrayBufferView,\n    descriptors?: FontFaceDescriptors,\n  ) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== 'string',\n      descriptors,\n      fontSource:\n        typeof source === 'string'\n          ? source\n          : // tslint:disable-next-line: no-any\n            JSON.stringify(Array.from(new Uint8Array(source as any))),\n    });\n    return fontFace;\n  } as unknown) as typeof FontFace;\n\n  const restoreHandler = patch(doc.fonts, 'add', function (original) {\n    return function (this: FontFaceSet, fontFace: FontFace) {\n      setTimeout(() => {\n        const p = fontMap.get(fontFace);\n        if (p) {\n          fontCb(p);\n          fontMap.delete(fontFace);\n        }\n      }, 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction mergeHooks(o: observerParam, hooks: hooksParam) {\n  const {\n    mutationCb,\n    mousemoveCb,\n    mouseInteractionCb,\n    scrollCb,\n    viewportResizeCb,\n    inputCb,\n    mediaInteractionCb,\n    styleSheetRuleCb,\n    styleDeclarationCb,\n    canvasMutationCb,\n    fontCb,\n  } = o;\n  o.mutationCb = (...p: Arguments<mutationCallBack>) => {\n    if (hooks.mutation) {\n      hooks.mutation(...p);\n    }\n    mutationCb(...p);\n  };\n  o.mousemoveCb = (...p: Arguments<mousemoveCallBack>) => {\n    if (hooks.mousemove) {\n      hooks.mousemove(...p);\n    }\n    mousemoveCb(...p);\n  };\n  o.mouseInteractionCb = (...p: Arguments<mouseInteractionCallBack>) => {\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction(...p);\n    }\n    mouseInteractionCb(...p);\n  };\n  o.scrollCb = (...p: Arguments<scrollCallback>) => {\n    if (hooks.scroll) {\n      hooks.scroll(...p);\n    }\n    scrollCb(...p);\n  };\n  o.viewportResizeCb = (...p: Arguments<viewportResizeCallback>) => {\n    if (hooks.viewportResize) {\n      hooks.viewportResize(...p);\n    }\n    viewportResizeCb(...p);\n  };\n  o.inputCb = (...p: Arguments<inputCallback>) => {\n    if (hooks.input) {\n      hooks.input(...p);\n    }\n    inputCb(...p);\n  };\n  o.mediaInteractionCb = (...p: Arguments<mediaInteractionCallback>) => {\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction(...p);\n    }\n    mediaInteractionCb(...p);\n  };\n  o.styleSheetRuleCb = (...p: Arguments<styleSheetRuleCallback>) => {\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule(...p);\n    }\n    styleSheetRuleCb(...p);\n  };\n  o.styleDeclarationCb = (...p: Arguments<styleDeclarationCallback>) => {\n    if (hooks.styleDeclaration) {\n      hooks.styleDeclaration(...p);\n    }\n    styleDeclarationCb(...p);\n  };\n  o.canvasMutationCb = (...p: Arguments<canvasMutationCallback>) => {\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation(...p);\n    }\n    canvasMutationCb(...p);\n  };\n  o.fontCb = (...p: Arguments<fontCallback>) => {\n    if (hooks.font) {\n      hooks.font(...p);\n    }\n    fontCb(...p);\n  };\n}\n\nexport function initObservers(\n  o: observerParam,\n  hooks: hooksParam = {},\n): listenerHandler {\n  const currentWindow = o.doc.defaultView; // basically document.window\n  if (!currentWindow) {\n    return () => {};\n  }\n\n  mergeHooks(o, hooks);\n  const mutationObserver = initMutationObserver(o, o.doc);\n  const mousemoveHandler = initMoveObserver(o);\n  const mouseInteractionHandler = initMouseInteractionObserver(o);\n  const scrollHandler = initScrollObserver(o);\n  const viewportResizeHandler = initViewportResizeObserver(o);\n  const inputHandler = initInputObserver(o);\n  const mediaInteractionHandler = initMediaInteractionObserver(o);\n\n  const styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });\n  const styleDeclarationObserver = initStyleDeclarationObserver(o, {\n    win: currentWindow,\n  });\n  const fontObserver = o.collectFonts ? initFontObserver(o) : () => {};\n  // plugins\n  const pluginHandlers: listenerHandler[] = [];\n  for (const plugin of o.plugins) {\n    pluginHandlers.push(\n      plugin.observer(plugin.callback, currentWindow, plugin.options),\n    );\n  }\n\n  return () => {\n    mutationBuffers.forEach((b) => b.reset());\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    pluginHandlers.forEach((h) => h());\n  };\n}\n","import { serializedNodeWithId, INode } from 'rrweb-snapshot';\nimport { mutationCallBack } from '../types';\n\nexport class IframeManager {\n  private iframes: WeakMap<HTMLIFrameElement, true> = new WeakMap();\n  private mutationCb: mutationCallBack;\n  private loadListener?: (iframeEl: HTMLIFrameElement) => unknown;\n\n  constructor(options: { mutationCb: mutationCallBack }) {\n    this.mutationCb = options.mutationCb;\n  }\n\n  public addIframe(iframeEl: HTMLIFrameElement) {\n    this.iframes.set(iframeEl, true);\n  }\n\n  public addLoadListener(cb: (iframeEl: HTMLIFrameElement) => unknown) {\n    this.loadListener = cb;\n  }\n\n  public attachIframe(iframeEl: INode, childSn: serializedNodeWithId) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: iframeEl.__sn.id,\n          nextId: null,\n          node: childSn,\n        },\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true,\n    });\n    this.loadListener?.((iframeEl as unknown) as HTMLIFrameElement);\n  }\n}\n","import {\n  mutationCallBack,\n  Mirror,\n  scrollCallback,\n  MutationBufferParam,\n  SamplingStrategy,\n} from '../types';\nimport { initMutationObserver, initScrollObserver } from './observer';\nimport { patch } from '../utils';\n\ntype BypassOptions = Omit<\n  MutationBufferParam,\n  'doc' | 'mutationCb' | 'mirror' | 'shadowDomManager'\n> & {\n  sampling: SamplingStrategy;\n};\n\nexport class ShadowDomManager {\n  private mutationCb: mutationCallBack;\n  private scrollCb: scrollCallback;\n  private bypassOptions: BypassOptions;\n  private mirror: Mirror;\n  private restorePatches: (() => void)[] = [];\n\n  constructor(options: {\n    mutationCb: mutationCallBack;\n    scrollCb: scrollCallback;\n    bypassOptions: BypassOptions;\n    mirror: Mirror;\n  }) {\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n\n    // Patch 'attachShadow' to observe newly added shadow doms.\n    const manager = this;\n    this.restorePatches.push(\n      patch(HTMLElement.prototype, 'attachShadow', function (original) {\n        return function () {\n          const shadowRoot = original.apply(this, arguments);\n          if (this.shadowRoot)\n            manager.addShadowRoot(this.shadowRoot, this.ownerDocument);\n          return shadowRoot;\n        };\n      }),\n    );\n  }\n\n  public addShadowRoot(shadowRoot: ShadowRoot, doc: Document) {\n    initMutationObserver(\n      {\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this,\n      },\n      shadowRoot,\n    );\n    initScrollObserver({\n      ...this.bypassOptions,\n      scrollCb: this.scrollCb,\n      // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n      // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n      doc: (shadowRoot as unknown) as Document,\n      mirror: this.mirror,\n    });\n  }\n\n  /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */\n  public observeAttachShadow(iframeElement: HTMLIFrameElement) {\n    if (iframeElement.contentWindow) {\n      const manager = this;\n      this.restorePatches.push(\n        patch(\n          (iframeElement.contentWindow as Window & {\n            HTMLElement: { prototype: HTMLElement };\n          }).HTMLElement.prototype,\n          'attachShadow',\n          function (original) {\n            return function () {\n              const shadowRoot = original.apply(this, arguments);\n              if (this.shadowRoot)\n                manager.addShadowRoot(\n                  this.shadowRoot,\n                  iframeElement.contentDocument as Document,\n                );\n              return shadowRoot;\n            };\n          },\n        ),\n      );\n    }\n  }\n\n  public reset() {\n    this.restorePatches.forEach((restorePatch) => restorePatch());\n  }\n}\n","/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { encode } from 'base64-arraybuffer';\nimport { IWindow, SerializedWebGlArg } from '../../../types';\n\n// TODO: unify with `replay/webgl.ts`\ntype GLVarMap = Map<string, any[]>;\nconst webGLVarMap: Map<\n  WebGLRenderingContext | WebGL2RenderingContext,\n  GLVarMap\n> = new Map();\nexport function variableListFor(\n  ctx: WebGLRenderingContext | WebGL2RenderingContext,\n  ctor: string,\n) {\n  let contextMap = webGLVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = new Map();\n    webGLVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor) as any[];\n}\n\nexport const saveWebGLVar = (\n  value: any,\n  win: IWindow,\n  ctx: WebGL2RenderingContext | WebGLRenderingContext,\n): number | void => {\n  if (\n    !value ||\n    !(isInstanceOfWebGLObject(value, win) || typeof value === 'object')\n  )\n    return;\n\n  const name = value.constructor.name;\n  const list = variableListFor(ctx, name);\n  let index = list.indexOf(value);\n\n  if (index === -1) {\n    index = list.length;\n    list.push(value);\n  }\n  return index;\n};\n\n// from webgl-recorder: https://github.com/evanw/webgl-recorder/blob/bef0e65596e981ee382126587e2dcbe0fc7748e2/webgl-recorder.js#L50-L77\nexport function serializeArg(\n  value: any,\n  win: IWindow,\n  ctx: WebGL2RenderingContext | WebGLRenderingContext,\n): SerializedWebGlArg {\n  if (value instanceof Array) {\n    return value.map((arg) => serializeArg(arg, win, ctx));\n  } else if (value === null) {\n    return value;\n  } else if (\n    value instanceof Float32Array ||\n    value instanceof Float64Array ||\n    value instanceof Int32Array ||\n    value instanceof Uint32Array ||\n    value instanceof Uint8Array ||\n    value instanceof Uint16Array ||\n    value instanceof Int16Array ||\n    value instanceof Int8Array ||\n    value instanceof Uint8ClampedArray\n  ) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [Object.values(value)],\n    };\n  } else if (\n    // SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    value instanceof ArrayBuffer\n  ) {\n    const name = value.constructor.name as 'ArrayBuffer';\n    const base64 = encode(value);\n\n    return {\n      rr_type: name,\n      base64,\n    };\n  } else if (value instanceof DataView) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [\n        serializeArg(value.buffer, win, ctx),\n        value.byteOffset,\n        value.byteLength,\n      ],\n    };\n  } else if (value instanceof HTMLImageElement) {\n    const name = value.constructor.name;\n    const { src } = value;\n    return {\n      rr_type: name,\n      src,\n    };\n  } else if (value instanceof ImageData) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [serializeArg(value.data, win, ctx), value.width, value.height],\n    };\n  } else if (isInstanceOfWebGLObject(value, win) || typeof value === 'object') {\n    const name = value.constructor.name;\n    const index = saveWebGLVar(value, win, ctx) as number;\n\n    return {\n      rr_type: name,\n      index: index,\n    };\n  }\n\n  return value;\n}\n\nexport const serializeArgs = (\n  args: Array<any>,\n  win: IWindow,\n  ctx: WebGLRenderingContext | WebGL2RenderingContext,\n) => {\n  return [...args].map((arg) => serializeArg(arg, win, ctx));\n};\n\nexport const isInstanceOfWebGLObject = (\n  value: any,\n  win: IWindow,\n): value is\n  | WebGLActiveInfo\n  | WebGLBuffer\n  | WebGLFramebuffer\n  | WebGLProgram\n  | WebGLRenderbuffer\n  | WebGLShader\n  | WebGLShaderPrecisionFormat\n  | WebGLTexture\n  | WebGLUniformLocation\n  | WebGLVertexArrayObject => {\n  const webGLConstructorNames: string[] = [\n    'WebGLActiveInfo',\n    'WebGLBuffer',\n    'WebGLFramebuffer',\n    'WebGLProgram',\n    'WebGLRenderbuffer',\n    'WebGLShader',\n    'WebGLShaderPrecisionFormat',\n    'WebGLTexture',\n    'WebGLUniformLocation',\n    'WebGLVertexArrayObject',\n    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n    'WebGLVertexArrayObjectOES',\n  ];\n  const supportedWebGLConstructorNames = webGLConstructorNames.filter(\n    (name: string) => typeof win[name as keyof Window] === 'function',\n  );\n  return Boolean(\n    supportedWebGLConstructorNames.find(\n      (name: string) => value instanceof win[name as keyof Window],\n    ),\n  );\n};\n","import { INode } from 'rrweb-snapshot';\nimport {\n  blockClass,\n  CanvasContext,\n  canvasManagerMutationCallback,\n  canvasMutationWithType,\n  IWindow,\n  listenerHandler,\n  Mirror,\n} from '../../../types';\nimport { hookSetter, isBlocked, patch } from '../../../utils';\nimport { saveWebGLVar, serializeArgs } from './serialize-args';\n\nfunction patchGLPrototype(\n  prototype: WebGLRenderingContext | WebGL2RenderingContext,\n  type: CanvasContext,\n  cb: canvasManagerMutationCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n  win: IWindow,\n): listenerHandler[] {\n  const handlers: listenerHandler[] = [];\n\n  const props = Object.getOwnPropertyNames(prototype);\n\n  for (const prop of props) {\n    try {\n      if (typeof prototype[prop as keyof typeof prototype] !== 'function') {\n        continue;\n      }\n      const restoreHandler = patch(prototype, prop, function (original) {\n        return function (this: typeof prototype, ...args: Array<unknown>) {\n          const result = original.apply(this, args);\n          saveWebGLVar(result, win, prototype);\n          if (!isBlocked((this.canvas as unknown) as INode, blockClass)) {\n            const id = mirror.getId((this.canvas as unknown) as INode);\n\n            const recordArgs = serializeArgs([...args], win, prototype);\n            const mutation: canvasMutationWithType = {\n              type,\n              property: prop,\n              args: recordArgs,\n            };\n            // TODO: this could potentially also be an OffscreenCanvas as well as HTMLCanvasElement\n            cb(this.canvas as HTMLCanvasElement, mutation);\n          }\n\n          return result;\n        };\n      });\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter<typeof prototype>(prototype, prop, {\n        set(v) {\n          // TODO: this could potentially also be an OffscreenCanvas as well as HTMLCanvasElement\n          cb(this.canvas as HTMLCanvasElement, {\n            type,\n            property: prop,\n            args: [v],\n            setter: true,\n          });\n        },\n      });\n      handlers.push(hookHandler);\n    }\n  }\n\n  return handlers;\n}\n\nexport default function initCanvasWebGLMutationObserver(\n  cb: canvasManagerMutationCallback,\n  win: IWindow,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const handlers: listenerHandler[] = [];\n\n  handlers.push(\n    ...patchGLPrototype(\n      win.WebGLRenderingContext.prototype,\n      CanvasContext.WebGL,\n      cb,\n      blockClass,\n      mirror,\n      win,\n    ),\n  );\n\n  if (typeof win.WebGL2RenderingContext !== 'undefined') {\n    handlers.push(\n      ...patchGLPrototype(\n        win.WebGL2RenderingContext.prototype,\n        CanvasContext.WebGL2,\n        cb,\n        blockClass,\n        mirror,\n        win,\n      ),\n    );\n  }\n\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n","import { INode } from 'rrweb-snapshot';\nimport {\n  blockClass,\n  canvasManagerMutationCallback,\n  canvasMutationCallback,\n  canvasMutationCommand,\n  canvasMutationWithType,\n  IWindow,\n  listenerHandler,\n  Mirror,\n} from '../../../types';\nimport initCanvas2DMutationObserver from './2d';\nimport initCanvasContextObserver from './canvas';\nimport initCanvasWebGLMutationObserver from './webgl';\n\nexport type RafStamps = { latestId: number; invokeId: number | null };\n\ntype pendingCanvasMutationsMap = Map<\n  HTMLCanvasElement,\n  canvasMutationWithType[]\n>;\n\nexport class CanvasManager {\n  private pendingCanvasMutations: pendingCanvasMutationsMap = new Map();\n  private rafStamps: RafStamps = { latestId: 0, invokeId: null };\n  private mirror: Mirror;\n\n  private mutationCb: canvasMutationCallback;\n  private resetObservers?: listenerHandler;\n  private frozen: boolean = false;\n  private locked: boolean = false;\n\n  public reset() {\n    this.pendingCanvasMutations.clear();\n    this.resetObservers && this.resetObservers();\n  }\n\n  public freeze() {\n    this.frozen = true;\n  }\n\n  public unfreeze() {\n    this.frozen = false;\n  }\n\n  public lock() {\n    this.locked = true;\n  }\n\n  public unlock() {\n    this.locked = false;\n  }\n\n  constructor(options: {\n    recordCanvas: boolean | number;\n    mutationCb: canvasMutationCallback;\n    win: IWindow;\n    blockClass: blockClass;\n    mirror: Mirror;\n  }) {\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n\n    if (options.recordCanvas === true)\n      this.initCanvasMutationObserver(options.win, options.blockClass);\n  }\n\n  private processMutation: canvasManagerMutationCallback = function (\n    target,\n    mutation,\n  ) {\n    const newFrame =\n      this.rafStamps.invokeId &&\n      this.rafStamps.latestId !== this.rafStamps.invokeId;\n    if (newFrame || !this.rafStamps.invokeId)\n      this.rafStamps.invokeId = this.rafStamps.latestId;\n\n    if (!this.pendingCanvasMutations.has(target)) {\n      this.pendingCanvasMutations.set(target, []);\n    }\n\n    this.pendingCanvasMutations.get(target)!.push(mutation);\n  };\n\n  private initCanvasMutationObserver(\n    win: IWindow,\n    blockClass: blockClass,\n  ): void {\n    this.startRAFTimestamping();\n    this.startPendingCanvasMutationFlusher();\n\n    const canvasContextReset = initCanvasContextObserver(win, blockClass);\n    const canvas2DReset = initCanvas2DMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      this.mirror,\n    );\n\n    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      this.mirror,\n    );\n\n    this.resetObservers = () => {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    };\n  }\n\n  private startPendingCanvasMutationFlusher() {\n    requestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n\n  private startRAFTimestamping() {\n    const setLatestRAFTimestamp = (timestamp: DOMHighResTimeStamp) => {\n      this.rafStamps.latestId = timestamp;\n      requestAnimationFrame(setLatestRAFTimestamp);\n    };\n    requestAnimationFrame(setLatestRAFTimestamp);\n  }\n\n  flushPendingCanvasMutations() {\n    this.pendingCanvasMutations.forEach(\n      (values: canvasMutationCommand[], canvas: HTMLCanvasElement) => {\n        const id = this.mirror.getId((canvas as unknown) as INode);\n        this.flushPendingCanvasMutationFor(canvas, id);\n      },\n    );\n    requestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n\n  flushPendingCanvasMutationFor(canvas: HTMLCanvasElement, id: number) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    const valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n\n    const values = valuesWithType.map((value) => {\n      const { type, ...rest } = value;\n      return rest;\n    });\n    const { type } = valuesWithType[0];\n\n    this.mutationCb({ id, type, commands: values });\n\n    this.pendingCanvasMutations.delete(canvas);\n  }\n}\n","import { snapshot, MaskInputOptions, SlimDOMOptions } from 'rrweb-snapshot';\nimport { initObservers, mutationBuffers } from './observer';\nimport {\n  on,\n  getWindowWidth,\n  getWindowHeight,\n  polyfill,\n  isIframeINode,\n  hasShadowRoot,\n  createMirror,\n} from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n  mutationCallbackParam,\n  scrollCallback,\n  canvasMutationParam,\n} from '../types';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\nimport { CanvasManager } from './observers/canvas/canvas-manager';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nlet wrappedEmit!: (e: eventWithTime, isCheckout?: boolean) => void;\n\nlet takeFullSnapshot!: (isCheckout?: boolean) => void;\n\nconst mirror = createMirror();\nfunction record<T = eventWithTime>(\n  options: recordOptions<T> = {},\n): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    blockSelector = null,\n    ignoreClass = 'rr-ignore',\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskInputFn,\n    maskTextFn,\n    hooks,\n    packFn,\n    sampling = {},\n    mousemoveWait,\n    recordCanvas = false,\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n  // move departed options to new options\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : _maskInputOptions !== undefined\n      ? _maskInputOptions\n      : { password: true };\n\n  const slimDOMOptions: SlimDOMOptions =\n    _slimDOMOptions === true || _slimDOMOptions === 'all'\n      ? {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaVerification: true,\n          // the following are off for slimDOMOptions === true,\n          // as they destroy some (hidden) info:\n          headMetaAuthorship: _slimDOMOptions === 'all',\n          headMetaDescKeywords: _slimDOMOptions === 'all',\n        }\n      : _slimDOMOptions\n      ? _slimDOMOptions\n      : {};\n\n  polyfill();\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = (e: eventWithTime): T => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e = plugin.eventProcessor(e);\n      }\n    }\n    if (packFn) {\n      e = (packFn(e) as unknown) as eventWithTime;\n    }\n    return (e as unknown) as T;\n  };\n  wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    if (\n      mutationBuffers[0]?.isFrozen() &&\n      e.type !== EventType.FullSnapshot &&\n      !(\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.Mutation\n      )\n    ) {\n      // we've got a user initiated event so first we need to apply\n      // all DOM changes that have been buffering during paused state\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n\n    emit(eventProcessor(e), isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      // attach iframe should be considered as full snapshot\n      if (\n        e.data.source === IncrementalSource.Mutation &&\n        e.data.isAttachIframe\n      ) {\n        return;\n      }\n\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  const wrappedMutationEmit = (m: mutationCallbackParam) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Mutation,\n          ...m,\n        },\n      }),\n    );\n  };\n  const wrappedScrollEmit: scrollCallback = (p) =>\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Scroll,\n          ...p,\n        },\n      }),\n    );\n  const wrappedCanvasMutationEmit = (p: canvasMutationParam) =>\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p,\n        },\n      }),\n    );\n\n  const iframeManager = new IframeManager({\n    mutationCb: wrappedMutationEmit,\n  });\n\n  const canvasManager = new CanvasManager({\n    recordCanvas,\n    mutationCb: wrappedCanvasMutationEmit,\n    win: window,\n    blockClass,\n    mirror,\n  });\n\n  const shadowDomManager = new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      canvasManager,\n    },\n    mirror,\n  });\n\n  takeFullSnapshot = (isCheckout = false) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n\n    mutationBuffers.forEach((buf) => buf.lock()); // don't allow any mirror modifications during snapshotting\n    const [node, idNodeMap] = snapshot(document, {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: (n) => {\n        if (isIframeINode(n)) {\n          iframeManager.addIframe(n);\n        }\n        if (hasShadowRoot(n)) {\n          shadowDomManager.addShadowRoot(n.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        shadowDomManager.observeAttachShadow(\n          (iframe as Node) as HTMLIFrameElement,\n        );\n      },\n      keepIframeSrcFn,\n    });\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left:\n              window.pageXOffset !== undefined\n                ? window.pageXOffset\n                : document?.documentElement.scrollLeft ||\n                  document?.body?.parentElement?.scrollLeft ||\n                  document?.body.scrollLeft ||\n                  0,\n            top:\n              window.pageYOffset !== undefined\n                ? window.pageYOffset\n                : document?.documentElement.scrollTop ||\n                  document?.body?.parentElement?.scrollTop ||\n                  document?.body.scrollTop ||\n                  0,\n          },\n        },\n      }),\n    );\n    mutationBuffers.forEach((buf) => buf.unlock()); // generate & emit any mutations that happened during snapshotting, as can now apply against the newly built mirror\n  };\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n\n    const observe = (doc: Document) => {\n      return initObservers(\n        {\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source,\n                  positions,\n                },\n              }),\n            ),\n          mouseInteractionCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseInteraction,\n                  ...d,\n                },\n              }),\n            ),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.ViewportResize,\n                  ...d,\n                },\n              }),\n            ),\n          inputCb: (v) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Input,\n                  ...v,\n                },\n              }),\n            ),\n          mediaInteractionCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MediaInteraction,\n                  ...p,\n                },\n              }),\n            ),\n          styleSheetRuleCb: (r) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.StyleSheetRule,\n                  ...r,\n                },\n              }),\n            ),\n          styleDeclarationCb: (r) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.StyleDeclaration,\n                  ...r,\n                },\n              }),\n            ),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Font,\n                  ...p,\n                },\n              }),\n            ),\n          blockClass,\n          ignoreClass,\n          maskTextClass,\n          maskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskInputFn,\n          maskTextFn,\n          blockSelector,\n          slimDOMOptions,\n          mirror,\n          iframeManager,\n          shadowDomManager,\n          canvasManager,\n          plugins:\n            plugins\n              ?.filter((p) => p.observer)\n              ?.map((p) => ({\n                observer: p.observer!,\n                options: p.options,\n                callback: (payload: object) =>\n                  wrappedEmit(\n                    wrapEvent({\n                      type: EventType.Plugin,\n                      data: {\n                        plugin: p.name,\n                        payload,\n                      },\n                    }),\n                  ),\n              })) || [],\n        },\n        hooks,\n      );\n    };\n\n    iframeManager.addLoadListener((iframeEl) => {\n      handlers.push(observe(iframeEl.contentDocument!));\n    });\n\n    const init = () => {\n      takeFullSnapshot();\n      handlers.push(observe(document));\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = <T>(tag: string, payload: T) => {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n  wrappedEmit(\n    wrapEvent({\n      type: EventType.Custom,\n      data: {\n        tag,\n        payload,\n      },\n    }),\n  );\n};\n\nrecord.freezePage = () => {\n  mutationBuffers.forEach((buf) => buf.freeze());\n};\n\nrecord.takeFullSnapshot = (isCheckout?: boolean) => {\n  if (!takeFullSnapshot) {\n    throw new Error('please take full snapshot after start recording');\n  }\n  takeFullSnapshot(isCheckout);\n};\n\nrecord.mirror = mirror;\n\nexport default record;\n","import { INode, ICanvas } from 'rrweb-snapshot';\nimport { blockClass, IWindow, listenerHandler } from '../../../types';\nimport { isBlocked, patch } from '../../../utils';\n\nexport default function initCanvasContextObserver(\n  win: IWindow,\n  blockClass: blockClass,\n): listenerHandler {\n  const handlers: listenerHandler[] = [];\n  try {\n    const restoreHandler = patch(\n      win.HTMLCanvasElement.prototype,\n      'getContext',\n      function (original) {\n        return function (\n          this: ICanvas,\n          contextType: string,\n          ...args: Array<unknown>\n        ) {\n          if (!isBlocked((this as unknown) as INode, blockClass)) {\n            if (!('__context' in this))\n              (this as ICanvas).__context = contextType;\n          }\n          return original.apply(this, [contextType, ...args]);\n        };\n      },\n    );\n    handlers.push(restoreHandler);\n  } catch {\n    console.error('failed to patch HTMLCanvasElement.prototype.getContext');\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n","import { INode } from 'rrweb-snapshot';\nimport {\n  blockClass,\n  CanvasContext,\n  canvasManagerMutationCallback,\n  IWindow,\n  listenerHandler,\n  Mirror,\n} from '../../../types';\nimport { hookSetter, isBlocked, patch } from '../../../utils';\n\nexport default function initCanvas2DMutationObserver(\n  cb: canvasManagerMutationCallback,\n  win: IWindow,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const handlers: listenerHandler[] = [];\n  const props2D = Object.getOwnPropertyNames(\n    win.CanvasRenderingContext2D.prototype,\n  );\n  for (const prop of props2D) {\n    try {\n      if (\n        typeof win.CanvasRenderingContext2D.prototype[\n          prop as keyof CanvasRenderingContext2D\n        ] !== 'function'\n      ) {\n        continue;\n      }\n      const restoreHandler = patch(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        function (original) {\n          return function (\n            this: CanvasRenderingContext2D,\n            ...args: Array<unknown>\n          ) {\n            if (!isBlocked((this.canvas as unknown) as INode, blockClass)) {\n              // Using setTimeout as getImageData + JSON.stringify can be heavy\n              // and we'd rather not block the main thread\n              setTimeout(() => {\n                const recordArgs = [...args];\n                if (prop === 'drawImage') {\n                  if (\n                    recordArgs[0] &&\n                    recordArgs[0] instanceof HTMLCanvasElement\n                  ) {\n                    const canvas = recordArgs[0];\n                    const ctx = canvas.getContext('2d');\n                    let imgd = ctx?.getImageData(\n                      0,\n                      0,\n                      canvas.width,\n                      canvas.height,\n                    );\n                    let pix = imgd?.data;\n                    recordArgs[0] = JSON.stringify(pix);\n                  }\n                }\n                cb(this.canvas, {\n                  type: CanvasContext['2D'],\n                  property: prop,\n                  args: recordArgs,\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        },\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter<CanvasRenderingContext2D>(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v) {\n            cb(this.canvas, {\n              type: CanvasContext['2D'],\n              property: prop,\n              args: [v],\n              setter: true,\n            });\n          },\n        },\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n"],"names":["NodeType","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","r","e","ar","push","error","__spreadArray","to","from","pack","l","Array","slice","concat","isShadowRoot","_a","host","Boolean","shadowRoot","maskInputValue","maskInputOptions","tagName","type","maskInputFn","text","toLowerCase","repeat","ORIGINAL_ATTRIBUTE_NAME","canvasService","canvasCtx","_id","tagNameRegex","RegExp","getCssRulesString","rules","cssRules","map","getCssRuleString","join","rule","cssStringified","cssText","isCSSImportRule","styleSheet","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","stack","parts","pop","_i","parts_1","part","EventType","IncrementalSource","MouseInteractions","CanvasContext","MediaInteractions","ReplayerEvents","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","document","transformAttribute","name","pos","collectCharacters","regEx","chars","match","exec","substring","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","nodeType","ELEMENT_NODE","classList","contains","eIndex","className","matches","parentNode","TEXT_NODE","serializeNode","options","rootId","sheet","el","blockClass","blockSelector","inlineStylesheet","_b","maskTextFn","_c","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","__sn","docId","id","undefined","DOCUMENT_NODE","compatMode","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes_1","_d","attributes","_e","name_1","stylesheet","styleSheets","find","rel","_cssText","innerText","textContent","checked","selected","__context","canvas","ctx","getContext","x","width","y","height","getImageData","originalGetImageData","Uint32Array","Math","min","data","buffer","some","pixel","is2DCanvasBlank","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","image_1","oldValue_1","crossOrigin","recordInlineImage","naturalWidth","naturalHeight","drawImage","err","console","warn","currentSrc","complete","onload","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_f","getBoundingClientRect","class","rr_width","rr_height","src","contentDocument","rr_src","Element","isSVG","ownerSVGElement","parentTagName","isStyle","isScript","nextSibling","previousSibling","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","serializeNodeWithId","skipChild","slimDOMOptions","onSerialize","onIframeLoad","_g","iframeLoadTimeout","_h","_j","preserveWhiteSpace","_serializedNode","sn","comment","script","as","endsWith","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","recordChild","isShadowHost","headWhitespace","bypassOptions","_k","serializedChildNode","isElement","_l","_m","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","setTimeout","timer_1","clearTimeout","onceIframeLoaded","iframeDoc","serializedIframeNode","on","fn","target","capture","passive","removeEventListener","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","getId","getNode","removeNodeFromMap","has","reset","throttle","func","wait","timeout","previous","arg","now","Date","leading","remaining","context","args","trailing","hookSetter","key","d","isRevoked","original","getOwnPropertyDescriptor","defineProperty","set","_this","patch","source","replacement","original_1","wrapped","defineProperties","__rrweb_original__","enumerable","getWindowHeight","window","innerHeight","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","needBlock_1","closest","forEach","isIgnored","isAncestorRemoved","mirror","isTouchEvent","event","changedTouches","isIframeINode","hasShadowRoot","isNodeInLinkedList","Proxy","Reflect","get","prop","receiver","DoubleLinkedList","position","Error","current","head","index","__ln","moveKey","parentId","isINode","Set","mutations","processMutation","emit","frozen","locked","adds","addList","getNextId","ns","nextId","pushAdd","shadowHost","getRootNode","rootShadowHost","notInDoc","addNode","currentN","iframeManager","addIframe","shadowDomManager","addShadowRoot","iframe","childSn","attachIframe","observeAttachShadow","mapRemoves","shift","movedSet","isParentRemoved","removes","addedSet","isAncestorInSet","droppedSet","add","candidate","_node","removeNode","payload","texts","filter","attribute","movedMap","mutationCb","oldValue","getAttribute","attributeName","item","old","setAttribute","style","styleObj","pname","newValue","getPropertyValue","newPriority","getPropertyPriority","addedNodes","genAdds","removedNodes","nodeId","deepDelete","targetId","delete","childN","MutationBuffer","canvasManager","freeze","unfreeze","lock","unlock","addsSet","mutationBuffers","isCSSGroupingRuleSupported","CSSGroupingRule","isCSSMediaRuleSupported","CSSMediaRule","isCSSSupportsRuleSupported","CSSSupportsRule","isCSSConditionRuleSupported","CSSConditionRule","getEventTarget","path","composedPath","initMutationObserver","rootEl","mutationBuffer","init","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","Zone","__symbol__","observer","processMutations","bind","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","initMouseInteractionObserver","mouseInteractionCb","sampling","mouseInteraction","disableMap","handlers","keys","Number","isNaN","eventKey","eventName","handler","clientX","clientY","getHandler","h","initScrollObserver","scrollCb","evt","scrollEl","scrollingElement","scroll","wrapEventWithUserTriggeredFlag","v","enable","userTriggered","INPUT_TAGS","lastInputValueMap","WeakMap","getNestedCSSRulePositions","childRule","parentRule","unshift","parentStyleSheet","recurse","initObservers","hooks","currentWindow","defaultView","mousemoveCb","viewportResizeCb","inputCb","mediaInteractionCb","styleSheetRuleCb","styleDeclarationCb","canvasMutationCb","fontCb","mutation","mousemove","viewportResize","input","mediaInteaction","styleSheetRule","styleDeclaration","canvasMutation","font","mergeHooks","mutationObserver","mousemoveHandler","timeBaseline","threshold","callbackThreshold","mousemoveCallback","positions","wrappedCb","totalOffset","timeOffset","updatePosition","DragEvent","Drag","MouseEvent","MouseMove","TouchMove","initMoveObserver","mouseInteractionHandler","scrollHandler","viewportResizeHandler","lastH","lastW","initViewportResizeObserver","inputHandler","ignoreClass","userTriggeredOnInput","eventHandler","isTrusted","parentElement","isChecked","cbWithDedup","querySelectorAll","lastInputValue","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","HTMLOptionElement","initInputObserver","mediaInteractionHandler","volume","muted","media","initMediaInteractionObserver","styleSheetObserver","insertRule","CSSStyleSheet","ownerNode","deleteRule","supportedNestedCSSRuleTypes","unmodifiedFunctions","entries","typeKey","initStyleSheetObserver","styleDeclarationObserver","setProperty","CSSStyleDeclaration","priority","removeProperty","remove","initStyleDeclarationObserver","fontObserver","collectFonts","fontMap","originalFontFace","FontFace","family","descriptors","fontFace","fontSource","JSON","stringify","Uint8Array","restoreHandler","fonts","initFontObserver","pluginHandlers","plugins","plugin","callback","b","disconnect","IframeManager","iframes","cb","loadListener","isAttachIframe","manager","restorePatches","HTMLElement","ownerDocument","ShadowDomManager","iframeElement","manager_1","restorePatch","lookup","charCodeAt","webGLVarMap","Map","saveWebGLVar","isInstanceOfWebGLObject","list","ctor","contextMap","variableListFor","constructor","serializeArg","Float32Array","Float64Array","Int32Array","Uint16Array","Int16Array","Int8Array","Uint8ClampedArray","rr_type","values","ArrayBuffer","base64","arraybuffer","bytes","len","encode","DataView","byteOffset","byteLength","HTMLImageElement","ImageData","serializeArgs","supportedWebGLConstructorNames","patchGLPrototype","props","getOwnPropertyNames","result","recordArgs","hookHandler","setter","props_1","wrappedEmit","takeFullSnapshot","latestId","invokeId","rafStamps","pendingCanvasMutations","initCanvasMutationObserver","CanvasManager","clear","resetObservers","startRAFTimestamping","startPendingCanvasMutationFlusher","canvasContextReset","HTMLCanvasElement","contextType","initCanvasContextObserver","canvas2DReset","props2D","CanvasRenderingContext2D","imgd","pix","props2D_1","initCanvas2DMutationObserver","canvasWebGL1and2Reset","WebGLRenderingContext","WebGL","WebGL2RenderingContext","WebGL2","initCanvasWebGLMutationObserver","requestAnimationFrame","flushPendingCanvasMutations","setLatestRAFTimestamp","timestamp","flushPendingCanvasMutationFor","valuesWithType","getOwnPropertySymbols","propertyIsEnumerable","commands","wrapEvent","child","record","checkoutEveryNms","checkoutEveryNth","maskAllInputs","_maskInputOptions","_slimDOMOptions","packFn","mousemoveWait","lastFullSnapshotEvent","color","date","email","month","number","range","search","tel","time","week","textarea","select","password","NodeList","DOMTokenList","Node","incrementalSnapshotCount","isCheckout","isFrozen","FullSnapshot","IncrementalSnapshot","Mutation","buf","eventProcessor","exceedCount","exceedTime","wrappedMutationEmit","wrappedScrollEmit","Scroll","wrappedCanvasMutationEmit","CanvasMutation","Meta","slimDOM","idNodeMap","snapshot","initialOffset","left","pageXOffset","top","pageYOffset","handlers_1","DomContentLoaded","observe_1","MouseInteraction","ViewportResize","Input","MediaInteraction","StyleSheetRule","StyleDeclaration","Font","Plugin","addLoadListener","init_1","Load","addCustomEvent","tag","Custom","freezePage"],"mappings":"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"}